// Code generated from ChainParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // ChainParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type ChainParser struct {
	ChainParserBase
}

var ChainParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func chainparserParserInit() {
	staticData := &ChainParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'break'", "'case'", "'chan'", "'const'", "'continue'", "'default'",
		"'defer'", "'else'", "'fallthrough'", "'for'", "'func'", "'go'", "'goto'",
		"'if'", "'import'", "'interface'", "'map'", "'nil'", "'package'", "'range'",
		"'return'", "'select'", "'struct'", "'switch'", "'type'", "'var'", "'workflow'",
		"'generates'", "'prerequisite'", "'nodes'", "'branches'", "'success'",
		"'error'", "'abort'", "'end'", "", "'('", "')'", "'{'", "'}'", "'['",
		"']'", "'='", "','", "';'", "':'", "'.'", "'++'", "'--'", "':='", "'...'",
		"'||'", "'&&'", "'=='", "'!='", "'<'", "'<='", "'>'", "'>='", "'|'",
		"'/'", "'%'", "'<<'", "'>>'", "'&^'", "'~'", "'!'", "'+'", "'-'", "'^'",
		"'*'", "'&'", "'<-'", "'-->'", "'<--'",
	}
	staticData.SymbolicNames = []string{
		"", "BREAK", "CASE", "CHAN", "CONST", "CONTINUE", "DEFAULT", "DEFER",
		"ELSE", "FALLTHROUGH", "FOR", "FUNC", "GO", "GOTO", "IF", "IMPORT",
		"INTERFACE", "MAP", "NIL_LIT", "PACKAGE", "RANGE", "RETURN", "SELECT",
		"STRUCT", "SWITCH", "TYPE", "VAR", "WORKFLOW", "GENERATES", "PREREQUISITE",
		"NODES", "BRANCHES", "SUCCESS", "ERROR", "ABORT", "END", "IDENTIFIER",
		"L_PAREN", "R_PAREN", "L_CURLY", "R_CURLY", "L_BRACKET", "R_BRACKET",
		"ASSIGN", "COMMA", "SEMI", "COLON", "DOT", "PLUS_PLUS", "MINUS_MINUS",
		"DECLARE_ASSIGN", "ELLIPSIS", "LOGICAL_OR", "LOGICAL_AND", "EQUALS",
		"NOT_EQUALS", "LESS", "LESS_OR_EQUALS", "GREATER", "GREATER_OR_EQUALS",
		"OR", "DIV", "MOD", "LSHIFT", "RSHIFT", "BIT_CLEAR", "UNDERLYING", "EXCLAMATION",
		"PLUS", "MINUS", "CARET", "STAR", "AMPERSAND", "RECEIVE", "L_TO_R",
		"R_TO_L", "DECIMAL_LIT", "BINARY_LIT", "OCTAL_LIT", "HEX_LIT", "FLOAT_LIT",
		"DECIMAL_FLOAT_LIT", "HEX_FLOAT_LIT", "IMAGINARY_LIT", "RUNE_LIT", "BYTE_VALUE",
		"OCTAL_BYTE_VALUE", "HEX_BYTE_VALUE", "LITTLE_U_VALUE", "BIG_U_VALUE",
		"RAW_STRING_LIT", "INTERPRETED_STRING_LIT", "WS", "COMMENT", "TERMINATOR",
		"LINE_COMMENT", "WS_NLSEMI", "COMMENT_NLSEMI", "LINE_COMMENT_NLSEMI",
		"EOS", "OTHER",
	}
	staticData.RuleNames = []string{
		"sourceFile", "workflowDecl", "workflowConstruct", "workflowSpec", "workflowBlock",
		"workflowStatementList", "prerequisteStatements", "prerequisiteStmt",
		"golangEmbedStatement", "nodesStatements", "nodeStmt", "directionStatements",
		"successStatements", "errorStatements", "abortStatements", "branchesStatements",
		"directionStmt", "nodeName", "branchStmt", "branchDirection", "chain_eos",
		"packageClause", "packageName", "identifier", "importDecl", "importSpec",
		"importPath", "declaration", "constDecl", "constSpec", "identifierList",
		"expressionList", "typeDecl", "typeSpec", "aliasDecl", "typeDef", "typeParameters",
		"typeParameterDecl", "typeElement", "typeTerm", "functionDecl", "methodDecl",
		"receiver", "varDecl", "varSpec", "block", "statementList", "statement",
		"simpleStmt", "expressionStmt", "sendStmt", "incDecStmt", "assignment",
		"assign_op", "shortVarDecl", "labeledStmt", "returnStmt", "breakStmt",
		"continueStmt", "gotoStmt", "fallthroughStmt", "deferStmt", "ifStmt",
		"switchStmt", "exprSwitchStmt", "exprCaseClause", "exprSwitchCase",
		"typeSwitchStmt", "typeSwitchGuard", "typeCaseClause", "typeSwitchCase",
		"typeList", "selectStmt", "commClause", "commCase", "recvStmt", "forStmt",
		"condition", "forClause", "rangeClause", "goStmt", "type_", "typeArgs",
		"typeName", "typeLit", "arrayType", "arrayLength", "elementType", "pointerType",
		"interfaceType", "sliceType", "mapType", "channelType", "methodSpec",
		"functionType", "signature", "result", "parameters", "parameterDecl",
		"expression", "primaryExpr", "conversion", "operand", "literal", "basicLit",
		"integer", "operandName", "qualifiedIdent", "compositeLit", "literalType",
		"literalValue", "elementList", "keyedElement", "key", "element", "structType",
		"fieldDecl", "string_", "embeddedField", "functionLit", "index", "slice_",
		"typeAssertion", "arguments", "methodExpr", "eos",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 100, 1207, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 1, 0, 1, 0,
		1, 0, 1, 0, 1, 0, 5, 0, 258, 8, 0, 10, 0, 12, 0, 261, 9, 0, 1, 0, 1, 0,
		1, 0, 5, 0, 266, 8, 0, 10, 0, 12, 0, 269, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1,
		1, 1, 1, 1, 3, 1, 277, 8, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 5, 5, 296,
		8, 5, 10, 5, 12, 5, 299, 9, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 5, 6, 306,
		8, 6, 10, 6, 12, 6, 309, 9, 6, 1, 7, 1, 7, 1, 7, 3, 7, 314, 8, 7, 1, 7,
		1, 7, 1, 7, 5, 7, 319, 8, 7, 10, 7, 12, 7, 322, 9, 7, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8,
		338, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 345, 8, 9, 10, 9, 12, 9,
		348, 9, 9, 1, 9, 5, 9, 351, 8, 9, 10, 9, 12, 9, 354, 9, 9, 1, 10, 1, 10,
		1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 362, 8, 11, 1, 12, 1, 12, 1, 12, 1,
		12, 3, 12, 368, 8, 12, 4, 12, 370, 8, 12, 11, 12, 12, 12, 371, 1, 13, 1,
		13, 1, 13, 1, 13, 3, 13, 378, 8, 13, 4, 13, 380, 8, 13, 11, 13, 12, 13,
		381, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 388, 8, 14, 4, 14, 390, 8, 14,
		11, 14, 12, 14, 391, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 398, 8, 15, 4,
		15, 400, 8, 15, 11, 15, 12, 15, 401, 1, 16, 1, 16, 1, 16, 5, 16, 407, 8,
		16, 10, 16, 12, 16, 410, 9, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 22, 1, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		5, 24, 439, 8, 24, 10, 24, 12, 24, 442, 9, 24, 1, 24, 3, 24, 445, 8, 24,
		1, 25, 1, 25, 3, 25, 449, 8, 25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1,
		27, 1, 27, 1, 27, 3, 27, 459, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		1, 28, 5, 28, 467, 8, 28, 10, 28, 12, 28, 470, 9, 28, 1, 28, 3, 28, 473,
		8, 28, 1, 29, 1, 29, 3, 29, 477, 8, 29, 1, 29, 1, 29, 3, 29, 481, 8, 29,
		1, 30, 1, 30, 1, 30, 5, 30, 486, 8, 30, 10, 30, 12, 30, 489, 9, 30, 1,
		31, 1, 31, 1, 31, 5, 31, 494, 8, 31, 10, 31, 12, 31, 497, 9, 31, 1, 32,
		1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 505, 8, 32, 10, 32, 12, 32, 508,
		9, 32, 1, 32, 3, 32, 511, 8, 32, 1, 33, 1, 33, 3, 33, 515, 8, 33, 1, 34,
		1, 34, 3, 34, 519, 8, 34, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 3, 35, 526,
		8, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 534, 8, 36, 10,
		36, 12, 36, 537, 9, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38,
		1, 38, 5, 38, 547, 8, 38, 10, 38, 12, 38, 550, 9, 38, 1, 39, 3, 39, 553,
		8, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 3, 40, 560, 8, 40, 1, 40, 1,
		40, 3, 40, 564, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 571, 8,
		41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 581,
		8, 43, 10, 43, 12, 43, 584, 9, 43, 1, 43, 3, 43, 587, 8, 43, 1, 44, 1,
		44, 1, 44, 1, 44, 3, 44, 593, 8, 44, 1, 44, 1, 44, 3, 44, 597, 8, 44, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 3, 46, 606, 8, 46, 1, 46,
		1, 46, 1, 46, 5, 46, 611, 8, 46, 10, 46, 12, 46, 614, 9, 46, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 3, 47, 631, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 3, 48, 638, 8, 48, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51,
		1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 3, 53, 654, 8, 53, 1,
		53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 3, 55, 665,
		8, 55, 1, 56, 1, 56, 3, 56, 669, 8, 56, 1, 57, 1, 57, 3, 57, 673, 8, 57,
		1, 58, 1, 58, 3, 58, 677, 8, 58, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1,
		61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		3, 62, 695, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 701, 8, 62, 3, 62,
		703, 8, 62, 1, 63, 1, 63, 3, 63, 707, 8, 63, 1, 64, 1, 64, 3, 64, 711,
		8, 64, 1, 64, 3, 64, 714, 8, 64, 1, 64, 1, 64, 3, 64, 718, 8, 64, 3, 64,
		720, 8, 64, 1, 64, 1, 64, 5, 64, 724, 8, 64, 10, 64, 12, 64, 727, 9, 64,
		1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 3, 66, 738,
		8, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3,
		67, 749, 8, 67, 1, 67, 1, 67, 5, 67, 753, 8, 67, 10, 67, 12, 67, 756, 9,
		67, 1, 67, 1, 67, 1, 68, 1, 68, 3, 68, 762, 8, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 3,
		70, 777, 8, 70, 1, 71, 1, 71, 3, 71, 781, 8, 71, 1, 71, 1, 71, 1, 71, 3,
		71, 786, 8, 71, 5, 71, 788, 8, 71, 10, 71, 12, 71, 791, 9, 71, 1, 72, 1,
		72, 1, 72, 5, 72, 796, 8, 72, 10, 72, 12, 72, 799, 9, 72, 1, 72, 1, 72,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 3, 74, 810, 8, 74, 1,
		74, 3, 74, 813, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75,
		821, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 829, 8, 76,
		1, 76, 1, 76, 1, 77, 1, 77, 1, 78, 3, 78, 836, 8, 78, 1, 78, 1, 78, 3,
		78, 840, 8, 78, 1, 78, 1, 78, 3, 78, 844, 8, 78, 1, 79, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 3, 79, 852, 8, 79, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80,
		1, 80, 1, 81, 1, 81, 3, 81, 862, 8, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1,
		81, 3, 81, 869, 8, 81, 1, 82, 1, 82, 1, 82, 3, 82, 874, 8, 82, 1, 82, 1,
		82, 1, 83, 1, 83, 3, 83, 880, 8, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84,
		1, 84, 1, 84, 1, 84, 3, 84, 890, 8, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 1, 86, 1, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89,
		1, 89, 3, 89, 908, 8, 89, 1, 89, 1, 89, 5, 89, 912, 8, 89, 10, 89, 12,
		89, 915, 9, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91,
		1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3,
		92, 935, 8, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93,
		3, 93, 945, 8, 93, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 3, 95, 952, 8, 95,
		1, 96, 1, 96, 3, 96, 956, 8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 5, 97, 962,
		8, 97, 10, 97, 12, 97, 965, 9, 97, 1, 97, 3, 97, 968, 8, 97, 3, 97, 970,
		8, 97, 1, 97, 1, 97, 1, 98, 3, 98, 975, 8, 98, 1, 98, 3, 98, 978, 8, 98,
		1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 986, 8, 99, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 5, 99, 1003, 8, 99, 10, 99, 12, 99, 1006, 9, 99, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1014, 8, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 5, 100, 1022, 8, 100, 10, 100,
		12, 100, 1025, 9, 100, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1031, 8,
		101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 3, 102, 1038, 8, 102, 1, 102,
		1, 102, 1, 102, 1, 102, 3, 102, 1044, 8, 102, 1, 103, 1, 103, 1, 103, 3,
		103, 1049, 8, 103, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1055, 8, 104,
		1, 105, 1, 105, 1, 106, 1, 106, 3, 106, 1061, 8, 106, 1, 107, 1, 107, 1,
		107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 1080, 8, 109, 3, 109,
		1082, 8, 109, 1, 110, 1, 110, 1, 110, 3, 110, 1087, 8, 110, 3, 110, 1089,
		8, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 5, 111, 1096, 8, 111, 10,
		111, 12, 111, 1099, 9, 111, 1, 112, 1, 112, 1, 112, 3, 112, 1104, 8, 112,
		1, 112, 1, 112, 1, 113, 1, 113, 3, 113, 1110, 8, 113, 1, 114, 1, 114, 3,
		114, 1114, 8, 114, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 5, 115, 1121,
		8, 115, 10, 115, 12, 115, 1124, 9, 115, 1, 115, 1, 115, 1, 116, 1, 116,
		1, 116, 1, 116, 3, 116, 1132, 8, 116, 1, 116, 3, 116, 1135, 8, 116, 1,
		117, 1, 117, 1, 118, 3, 118, 1140, 8, 118, 1, 118, 1, 118, 3, 118, 1144,
		8, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 120,
		1, 121, 1, 121, 3, 121, 1156, 8, 121, 1, 121, 1, 121, 3, 121, 1160, 8,
		121, 1, 121, 3, 121, 1163, 8, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121,
		3, 121, 1170, 8, 121, 1, 121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1,
		122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1184, 8, 123, 3, 123,
		1186, 8, 123, 1, 123, 3, 123, 1189, 8, 123, 1, 123, 3, 123, 1192, 8, 123,
		3, 123, 1194, 8, 123, 1, 123, 1, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1,
		125, 1, 125, 1, 125, 3, 125, 1205, 8, 125, 1, 125, 0, 1, 198, 126, 0, 2,
		4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40,
		42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76,
		78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110,
		112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140,
		142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170,
		172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200,
		202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230,
		232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 0, 11, 1, 0, 74, 75,
		1, 0, 35, 36, 1, 0, 48, 49, 2, 0, 60, 65, 68, 72, 2, 0, 45, 45, 99, 99,
		1, 0, 67, 73, 2, 0, 61, 65, 71, 72, 2, 0, 60, 60, 68, 70, 1, 0, 54, 59,
		2, 0, 76, 79, 83, 84, 1, 0, 90, 91, 1275, 0, 252, 1, 0, 0, 0, 2, 272, 1,
		0, 0, 0, 4, 281, 1, 0, 0, 0, 6, 283, 1, 0, 0, 0, 8, 288, 1, 0, 0, 0, 10,
		292, 1, 0, 0, 0, 12, 300, 1, 0, 0, 0, 14, 320, 1, 0, 0, 0, 16, 337, 1,
		0, 0, 0, 18, 339, 1, 0, 0, 0, 20, 355, 1, 0, 0, 0, 22, 361, 1, 0, 0, 0,
		24, 363, 1, 0, 0, 0, 26, 373, 1, 0, 0, 0, 28, 383, 1, 0, 0, 0, 30, 393,
		1, 0, 0, 0, 32, 403, 1, 0, 0, 0, 34, 411, 1, 0, 0, 0, 36, 413, 1, 0, 0,
		0, 38, 417, 1, 0, 0, 0, 40, 422, 1, 0, 0, 0, 42, 424, 1, 0, 0, 0, 44, 428,
		1, 0, 0, 0, 46, 430, 1, 0, 0, 0, 48, 432, 1, 0, 0, 0, 50, 448, 1, 0, 0,
		0, 52, 453, 1, 0, 0, 0, 54, 458, 1, 0, 0, 0, 56, 460, 1, 0, 0, 0, 58, 474,
		1, 0, 0, 0, 60, 482, 1, 0, 0, 0, 62, 490, 1, 0, 0, 0, 64, 498, 1, 0, 0,
		0, 66, 514, 1, 0, 0, 0, 68, 516, 1, 0, 0, 0, 70, 523, 1, 0, 0, 0, 72, 529,
		1, 0, 0, 0, 74, 540, 1, 0, 0, 0, 76, 543, 1, 0, 0, 0, 78, 552, 1, 0, 0,
		0, 80, 556, 1, 0, 0, 0, 82, 565, 1, 0, 0, 0, 84, 572, 1, 0, 0, 0, 86, 574,
		1, 0, 0, 0, 88, 588, 1, 0, 0, 0, 90, 598, 1, 0, 0, 0, 92, 612, 1, 0, 0,
		0, 94, 630, 1, 0, 0, 0, 96, 637, 1, 0, 0, 0, 98, 639, 1, 0, 0, 0, 100,
		641, 1, 0, 0, 0, 102, 645, 1, 0, 0, 0, 104, 648, 1, 0, 0, 0, 106, 653,
		1, 0, 0, 0, 108, 657, 1, 0, 0, 0, 110, 661, 1, 0, 0, 0, 112, 666, 1, 0,
		0, 0, 114, 670, 1, 0, 0, 0, 116, 674, 1, 0, 0, 0, 118, 678, 1, 0, 0, 0,
		120, 681, 1, 0, 0, 0, 122, 683, 1, 0, 0, 0, 124, 686, 1, 0, 0, 0, 126,
		706, 1, 0, 0, 0, 128, 708, 1, 0, 0, 0, 130, 730, 1, 0, 0, 0, 132, 737,
		1, 0, 0, 0, 134, 739, 1, 0, 0, 0, 136, 761, 1, 0, 0, 0, 138, 769, 1, 0,
		0, 0, 140, 776, 1, 0, 0, 0, 142, 780, 1, 0, 0, 0, 144, 792, 1, 0, 0, 0,
		146, 802, 1, 0, 0, 0, 148, 812, 1, 0, 0, 0, 150, 820, 1, 0, 0, 0, 152,
		824, 1, 0, 0, 0, 154, 832, 1, 0, 0, 0, 156, 835, 1, 0, 0, 0, 158, 851,
		1, 0, 0, 0, 160, 856, 1, 0, 0, 0, 162, 868, 1, 0, 0, 0, 164, 870, 1, 0,
		0, 0, 166, 879, 1, 0, 0, 0, 168, 889, 1, 0, 0, 0, 170, 891, 1, 0, 0, 0,
		172, 896, 1, 0, 0, 0, 174, 898, 1, 0, 0, 0, 176, 900, 1, 0, 0, 0, 178,
		903, 1, 0, 0, 0, 180, 918, 1, 0, 0, 0, 182, 922, 1, 0, 0, 0, 184, 934,
		1, 0, 0, 0, 186, 944, 1, 0, 0, 0, 188, 946, 1, 0, 0, 0, 190, 949, 1, 0,
		0, 0, 192, 955, 1, 0, 0, 0, 194, 957, 1, 0, 0, 0, 196, 974, 1, 0, 0, 0,
		198, 985, 1, 0, 0, 0, 200, 1013, 1, 0, 0, 0, 202, 1026, 1, 0, 0, 0, 204,
		1043, 1, 0, 0, 0, 206, 1048, 1, 0, 0, 0, 208, 1054, 1, 0, 0, 0, 210, 1056,
		1, 0, 0, 0, 212, 1060, 1, 0, 0, 0, 214, 1062, 1, 0, 0, 0, 216, 1066, 1,
		0, 0, 0, 218, 1081, 1, 0, 0, 0, 220, 1083, 1, 0, 0, 0, 222, 1092, 1, 0,
		0, 0, 224, 1103, 1, 0, 0, 0, 226, 1109, 1, 0, 0, 0, 228, 1113, 1, 0, 0,
		0, 230, 1115, 1, 0, 0, 0, 232, 1131, 1, 0, 0, 0, 234, 1136, 1, 0, 0, 0,
		236, 1139, 1, 0, 0, 0, 238, 1145, 1, 0, 0, 0, 240, 1149, 1, 0, 0, 0, 242,
		1153, 1, 0, 0, 0, 244, 1173, 1, 0, 0, 0, 246, 1178, 1, 0, 0, 0, 248, 1197,
		1, 0, 0, 0, 250, 1204, 1, 0, 0, 0, 252, 253, 3, 42, 21, 0, 253, 259, 3,
		250, 125, 0, 254, 255, 3, 48, 24, 0, 255, 256, 3, 250, 125, 0, 256, 258,
		1, 0, 0, 0, 257, 254, 1, 0, 0, 0, 258, 261, 1, 0, 0, 0, 259, 257, 1, 0,
		0, 0, 259, 260, 1, 0, 0, 0, 260, 267, 1, 0, 0, 0, 261, 259, 1, 0, 0, 0,
		262, 263, 3, 2, 1, 0, 263, 264, 3, 250, 125, 0, 264, 266, 1, 0, 0, 0, 265,
		262, 1, 0, 0, 0, 266, 269, 1, 0, 0, 0, 267, 265, 1, 0, 0, 0, 267, 268,
		1, 0, 0, 0, 268, 270, 1, 0, 0, 0, 269, 267, 1, 0, 0, 0, 270, 271, 5, 0,
		0, 1, 271, 1, 1, 0, 0, 0, 272, 273, 5, 27, 0, 0, 273, 274, 3, 4, 2, 0,
		274, 276, 3, 194, 97, 0, 275, 277, 5, 28, 0, 0, 276, 275, 1, 0, 0, 0, 276,
		277, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 279, 3, 6, 3, 0, 279, 280,
		3, 8, 4, 0, 280, 3, 1, 0, 0, 0, 281, 282, 5, 36, 0, 0, 282, 5, 1, 0, 0,
		0, 283, 284, 5, 36, 0, 0, 284, 285, 5, 41, 0, 0, 285, 286, 3, 76, 38, 0,
		286, 287, 5, 42, 0, 0, 287, 7, 1, 0, 0, 0, 288, 289, 5, 39, 0, 0, 289,
		290, 3, 10, 5, 0, 290, 291, 5, 40, 0, 0, 291, 9, 1, 0, 0, 0, 292, 293,
		3, 12, 6, 0, 293, 297, 3, 18, 9, 0, 294, 296, 3, 22, 11, 0, 295, 294, 1,
		0, 0, 0, 296, 299, 1, 0, 0, 0, 297, 295, 1, 0, 0, 0, 297, 298, 1, 0, 0,
		0, 298, 11, 1, 0, 0, 0, 299, 297, 1, 0, 0, 0, 300, 301, 5, 29, 0, 0, 301,
		302, 5, 39, 0, 0, 302, 303, 3, 14, 7, 0, 303, 307, 5, 40, 0, 0, 304, 306,
		5, 99, 0, 0, 305, 304, 1, 0, 0, 0, 306, 309, 1, 0, 0, 0, 307, 305, 1, 0,
		0, 0, 307, 308, 1, 0, 0, 0, 308, 13, 1, 0, 0, 0, 309, 307, 1, 0, 0, 0,
		310, 314, 5, 45, 0, 0, 311, 314, 5, 99, 0, 0, 312, 314, 1, 0, 0, 0, 313,
		310, 1, 0, 0, 0, 313, 311, 1, 0, 0, 0, 313, 312, 1, 0, 0, 0, 314, 315,
		1, 0, 0, 0, 315, 316, 3, 16, 8, 0, 316, 317, 3, 250, 125, 0, 317, 319,
		1, 0, 0, 0, 318, 313, 1, 0, 0, 0, 319, 322, 1, 0, 0, 0, 320, 318, 1, 0,
		0, 0, 320, 321, 1, 0, 0, 0, 321, 15, 1, 0, 0, 0, 322, 320, 1, 0, 0, 0,
		323, 338, 3, 54, 27, 0, 324, 338, 3, 110, 55, 0, 325, 338, 3, 96, 48, 0,
		326, 338, 3, 160, 80, 0, 327, 338, 3, 114, 57, 0, 328, 338, 3, 116, 58,
		0, 329, 338, 3, 118, 59, 0, 330, 338, 3, 120, 60, 0, 331, 338, 3, 90, 45,
		0, 332, 338, 3, 124, 62, 0, 333, 338, 3, 126, 63, 0, 334, 338, 3, 144,
		72, 0, 335, 338, 3, 152, 76, 0, 336, 338, 3, 122, 61, 0, 337, 323, 1, 0,
		0, 0, 337, 324, 1, 0, 0, 0, 337, 325, 1, 0, 0, 0, 337, 326, 1, 0, 0, 0,
		337, 327, 1, 0, 0, 0, 337, 328, 1, 0, 0, 0, 337, 329, 1, 0, 0, 0, 337,
		330, 1, 0, 0, 0, 337, 331, 1, 0, 0, 0, 337, 332, 1, 0, 0, 0, 337, 333,
		1, 0, 0, 0, 337, 334, 1, 0, 0, 0, 337, 335, 1, 0, 0, 0, 337, 336, 1, 0,
		0, 0, 338, 17, 1, 0, 0, 0, 339, 340, 5, 30, 0, 0, 340, 346, 5, 46, 0, 0,
		341, 342, 3, 20, 10, 0, 342, 343, 3, 250, 125, 0, 343, 345, 1, 0, 0, 0,
		344, 341, 1, 0, 0, 0, 345, 348, 1, 0, 0, 0, 346, 344, 1, 0, 0, 0, 346,
		347, 1, 0, 0, 0, 347, 352, 1, 0, 0, 0, 348, 346, 1, 0, 0, 0, 349, 351,
		5, 99, 0, 0, 350, 349, 1, 0, 0, 0, 351, 354, 1, 0, 0, 0, 352, 350, 1, 0,
		0, 0, 352, 353, 1, 0, 0, 0, 353, 19, 1, 0, 0, 0, 354, 352, 1, 0, 0, 0,
		355, 356, 3, 60, 30, 0, 356, 21, 1, 0, 0, 0, 357, 362, 3, 24, 12, 0, 358,
		362, 3, 26, 13, 0, 359, 362, 3, 28, 14, 0, 360, 362, 3, 30, 15, 0, 361,
		357, 1, 0, 0, 0, 361, 358, 1, 0, 0, 0, 361, 359, 1, 0, 0, 0, 361, 360,
		1, 0, 0, 0, 362, 23, 1, 0, 0, 0, 363, 364, 5, 32, 0, 0, 364, 369, 5, 46,
		0, 0, 365, 367, 3, 32, 16, 0, 366, 368, 3, 40, 20, 0, 367, 366, 1, 0, 0,
		0, 367, 368, 1, 0, 0, 0, 368, 370, 1, 0, 0, 0, 369, 365, 1, 0, 0, 0, 370,
		371, 1, 0, 0, 0, 371, 369, 1, 0, 0, 0, 371, 372, 1, 0, 0, 0, 372, 25, 1,
		0, 0, 0, 373, 374, 5, 33, 0, 0, 374, 379, 5, 46, 0, 0, 375, 377, 3, 32,
		16, 0, 376, 378, 3, 40, 20, 0, 377, 376, 1, 0, 0, 0, 377, 378, 1, 0, 0,
		0, 378, 380, 1, 0, 0, 0, 379, 375, 1, 0, 0, 0, 380, 381, 1, 0, 0, 0, 381,
		379, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0, 382, 27, 1, 0, 0, 0, 383, 384, 5,
		34, 0, 0, 384, 389, 5, 46, 0, 0, 385, 387, 3, 32, 16, 0, 386, 388, 3, 40,
		20, 0, 387, 386, 1, 0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 390, 1, 0, 0, 0,
		389, 385, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 389, 1, 0, 0, 0, 391,
		392, 1, 0, 0, 0, 392, 29, 1, 0, 0, 0, 393, 394, 5, 31, 0, 0, 394, 399,
		5, 46, 0, 0, 395, 397, 3, 36, 18, 0, 396, 398, 3, 40, 20, 0, 397, 396,
		1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 400, 1, 0, 0, 0, 399, 395, 1, 0,
		0, 0, 400, 401, 1, 0, 0, 0, 401, 399, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0,
		402, 31, 1, 0, 0, 0, 403, 408, 3, 34, 17, 0, 404, 405, 7, 0, 0, 0, 405,
		407, 3, 34, 17, 0, 406, 404, 1, 0, 0, 0, 407, 410, 1, 0, 0, 0, 408, 406,
		1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 33, 1, 0, 0, 0, 410, 408, 1, 0,
		0, 0, 411, 412, 7, 1, 0, 0, 412, 35, 1, 0, 0, 0, 413, 414, 5, 36, 0, 0,
		414, 415, 3, 38, 19, 0, 415, 416, 3, 34, 17, 0, 416, 37, 1, 0, 0, 0, 417,
		418, 5, 69, 0, 0, 418, 419, 3, 234, 117, 0, 419, 420, 5, 69, 0, 0, 420,
		421, 5, 58, 0, 0, 421, 39, 1, 0, 0, 0, 422, 423, 5, 99, 0, 0, 423, 41,
		1, 0, 0, 0, 424, 425, 5, 19, 0, 0, 425, 426, 3, 44, 22, 0, 426, 427, 6,
		21, -1, 0, 427, 43, 1, 0, 0, 0, 428, 429, 3, 46, 23, 0, 429, 45, 1, 0,
		0, 0, 430, 431, 5, 36, 0, 0, 431, 47, 1, 0, 0, 0, 432, 444, 5, 15, 0, 0,
		433, 445, 3, 50, 25, 0, 434, 440, 5, 37, 0, 0, 435, 436, 3, 50, 25, 0,
		436, 437, 3, 250, 125, 0, 437, 439, 1, 0, 0, 0, 438, 435, 1, 0, 0, 0, 439,
		442, 1, 0, 0, 0, 440, 438, 1, 0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 443,
		1, 0, 0, 0, 442, 440, 1, 0, 0, 0, 443, 445, 5, 38, 0, 0, 444, 433, 1, 0,
		0, 0, 444, 434, 1, 0, 0, 0, 445, 49, 1, 0, 0, 0, 446, 449, 5, 47, 0, 0,
		447, 449, 3, 44, 22, 0, 448, 446, 1, 0, 0, 0, 448, 447, 1, 0, 0, 0, 448,
		449, 1, 0, 0, 0, 449, 450, 1, 0, 0, 0, 450, 451, 3, 52, 26, 0, 451, 452,
		6, 25, -1, 0, 452, 51, 1, 0, 0, 0, 453, 454, 3, 234, 117, 0, 454, 53, 1,
		0, 0, 0, 455, 459, 3, 56, 28, 0, 456, 459, 3, 64, 32, 0, 457, 459, 3, 86,
		43, 0, 458, 455, 1, 0, 0, 0, 458, 456, 1, 0, 0, 0, 458, 457, 1, 0, 0, 0,
		459, 55, 1, 0, 0, 0, 460, 472, 5, 4, 0, 0, 461, 473, 3, 58, 29, 0, 462,
		468, 5, 37, 0, 0, 463, 464, 3, 58, 29, 0, 464, 465, 3, 250, 125, 0, 465,
		467, 1, 0, 0, 0, 466, 463, 1, 0, 0, 0, 467, 470, 1, 0, 0, 0, 468, 466,
		1, 0, 0, 0, 468, 469, 1, 0, 0, 0, 469, 471, 1, 0, 0, 0, 470, 468, 1, 0,
		0, 0, 471, 473, 5, 38, 0, 0, 472, 461, 1, 0, 0, 0, 472, 462, 1, 0, 0, 0,
		473, 57, 1, 0, 0, 0, 474, 480, 3, 60, 30, 0, 475, 477, 3, 162, 81, 0, 476,
		475, 1, 0, 0, 0, 476, 477, 1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478, 479,
		5, 43, 0, 0, 479, 481, 3, 62, 31, 0, 480, 476, 1, 0, 0, 0, 480, 481, 1,
		0, 0, 0, 481, 59, 1, 0, 0, 0, 482, 487, 5, 36, 0, 0, 483, 484, 5, 44, 0,
		0, 484, 486, 5, 36, 0, 0, 485, 483, 1, 0, 0, 0, 486, 489, 1, 0, 0, 0, 487,
		485, 1, 0, 0, 0, 487, 488, 1, 0, 0, 0, 488, 61, 1, 0, 0, 0, 489, 487, 1,
		0, 0, 0, 490, 495, 3, 198, 99, 0, 491, 492, 5, 44, 0, 0, 492, 494, 3, 198,
		99, 0, 493, 491, 1, 0, 0, 0, 494, 497, 1, 0, 0, 0, 495, 493, 1, 0, 0, 0,
		495, 496, 1, 0, 0, 0, 496, 63, 1, 0, 0, 0, 497, 495, 1, 0, 0, 0, 498, 510,
		5, 25, 0, 0, 499, 511, 3, 66, 33, 0, 500, 506, 5, 37, 0, 0, 501, 502, 3,
		66, 33, 0, 502, 503, 3, 250, 125, 0, 503, 505, 1, 0, 0, 0, 504, 501, 1,
		0, 0, 0, 505, 508, 1, 0, 0, 0, 506, 504, 1, 0, 0, 0, 506, 507, 1, 0, 0,
		0, 507, 509, 1, 0, 0, 0, 508, 506, 1, 0, 0, 0, 509, 511, 5, 38, 0, 0, 510,
		499, 1, 0, 0, 0, 510, 500, 1, 0, 0, 0, 511, 65, 1, 0, 0, 0, 512, 515, 3,
		68, 34, 0, 513, 515, 3, 70, 35, 0, 514, 512, 1, 0, 0, 0, 514, 513, 1, 0,
		0, 0, 515, 67, 1, 0, 0, 0, 516, 518, 5, 36, 0, 0, 517, 519, 3, 72, 36,
		0, 518, 517, 1, 0, 0, 0, 518, 519, 1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520,
		521, 5, 43, 0, 0, 521, 522, 3, 162, 81, 0, 522, 69, 1, 0, 0, 0, 523, 525,
		5, 36, 0, 0, 524, 526, 3, 72, 36, 0, 525, 524, 1, 0, 0, 0, 525, 526, 1,
		0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 528, 3, 162, 81, 0, 528, 71, 1, 0,
		0, 0, 529, 530, 5, 41, 0, 0, 530, 535, 3, 74, 37, 0, 531, 532, 5, 44, 0,
		0, 532, 534, 3, 74, 37, 0, 533, 531, 1, 0, 0, 0, 534, 537, 1, 0, 0, 0,
		535, 533, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0, 536, 538, 1, 0, 0, 0, 537,
		535, 1, 0, 0, 0, 538, 539, 5, 42, 0, 0, 539, 73, 1, 0, 0, 0, 540, 541,
		3, 60, 30, 0, 541, 542, 3, 76, 38, 0, 542, 75, 1, 0, 0, 0, 543, 548, 3,
		78, 39, 0, 544, 545, 5, 60, 0, 0, 545, 547, 3, 78, 39, 0, 546, 544, 1,
		0, 0, 0, 547, 550, 1, 0, 0, 0, 548, 546, 1, 0, 0, 0, 548, 549, 1, 0, 0,
		0, 549, 77, 1, 0, 0, 0, 550, 548, 1, 0, 0, 0, 551, 553, 5, 66, 0, 0, 552,
		551, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 555,
		3, 162, 81, 0, 555, 79, 1, 0, 0, 0, 556, 557, 5, 11, 0, 0, 557, 559, 5,
		36, 0, 0, 558, 560, 3, 72, 36, 0, 559, 558, 1, 0, 0, 0, 559, 560, 1, 0,
		0, 0, 560, 561, 1, 0, 0, 0, 561, 563, 3, 190, 95, 0, 562, 564, 3, 90, 45,
		0, 563, 562, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564, 81, 1, 0, 0, 0, 565,
		566, 5, 11, 0, 0, 566, 567, 3, 84, 42, 0, 567, 568, 5, 36, 0, 0, 568, 570,
		3, 190, 95, 0, 569, 571, 3, 90, 45, 0, 570, 569, 1, 0, 0, 0, 570, 571,
		1, 0, 0, 0, 571, 83, 1, 0, 0, 0, 572, 573, 3, 194, 97, 0, 573, 85, 1, 0,
		0, 0, 574, 586, 5, 26, 0, 0, 575, 587, 3, 88, 44, 0, 576, 582, 5, 37, 0,
		0, 577, 578, 3, 88, 44, 0, 578, 579, 3, 250, 125, 0, 579, 581, 1, 0, 0,
		0, 580, 577, 1, 0, 0, 0, 581, 584, 1, 0, 0, 0, 582, 580, 1, 0, 0, 0, 582,
		583, 1, 0, 0, 0, 583, 585, 1, 0, 0, 0, 584, 582, 1, 0, 0, 0, 585, 587,
		5, 38, 0, 0, 586, 575, 1, 0, 0, 0, 586, 576, 1, 0, 0, 0, 587, 87, 1, 0,
		0, 0, 588, 596, 3, 60, 30, 0, 589, 592, 3, 162, 81, 0, 590, 591, 5, 43,
		0, 0, 591, 593, 3, 62, 31, 0, 592, 590, 1, 0, 0, 0, 592, 593, 1, 0, 0,
		0, 593, 597, 1, 0, 0, 0, 594, 595, 5, 43, 0, 0, 595, 597, 3, 62, 31, 0,
		596, 589, 1, 0, 0, 0, 596, 594, 1, 0, 0, 0, 597, 89, 1, 0, 0, 0, 598, 599,
		5, 39, 0, 0, 599, 600, 3, 92, 46, 0, 600, 601, 5, 40, 0, 0, 601, 91, 1,
		0, 0, 0, 602, 606, 5, 45, 0, 0, 603, 606, 5, 99, 0, 0, 604, 606, 1, 0,
		0, 0, 605, 602, 1, 0, 0, 0, 605, 603, 1, 0, 0, 0, 605, 604, 1, 0, 0, 0,
		606, 607, 1, 0, 0, 0, 607, 608, 3, 94, 47, 0, 608, 609, 3, 250, 125, 0,
		609, 611, 1, 0, 0, 0, 610, 605, 1, 0, 0, 0, 611, 614, 1, 0, 0, 0, 612,
		610, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 93, 1, 0, 0, 0, 614, 612, 1,
		0, 0, 0, 615, 631, 3, 54, 27, 0, 616, 631, 3, 110, 55, 0, 617, 631, 3,
		96, 48, 0, 618, 631, 3, 160, 80, 0, 619, 631, 3, 112, 56, 0, 620, 631,
		3, 114, 57, 0, 621, 631, 3, 116, 58, 0, 622, 631, 3, 118, 59, 0, 623, 631,
		3, 120, 60, 0, 624, 631, 3, 90, 45, 0, 625, 631, 3, 124, 62, 0, 626, 631,
		3, 126, 63, 0, 627, 631, 3, 144, 72, 0, 628, 631, 3, 152, 76, 0, 629, 631,
		3, 122, 61, 0, 630, 615, 1, 0, 0, 0, 630, 616, 1, 0, 0, 0, 630, 617, 1,
		0, 0, 0, 630, 618, 1, 0, 0, 0, 630, 619, 1, 0, 0, 0, 630, 620, 1, 0, 0,
		0, 630, 621, 1, 0, 0, 0, 630, 622, 1, 0, 0, 0, 630, 623, 1, 0, 0, 0, 630,
		624, 1, 0, 0, 0, 630, 625, 1, 0, 0, 0, 630, 626, 1, 0, 0, 0, 630, 627,
		1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 630, 629, 1, 0, 0, 0, 631, 95, 1, 0,
		0, 0, 632, 638, 3, 100, 50, 0, 633, 638, 3, 102, 51, 0, 634, 638, 3, 104,
		52, 0, 635, 638, 3, 98, 49, 0, 636, 638, 3, 108, 54, 0, 637, 632, 1, 0,
		0, 0, 637, 633, 1, 0, 0, 0, 637, 634, 1, 0, 0, 0, 637, 635, 1, 0, 0, 0,
		637, 636, 1, 0, 0, 0, 638, 97, 1, 0, 0, 0, 639, 640, 3, 198, 99, 0, 640,
		99, 1, 0, 0, 0, 641, 642, 3, 198, 99, 0, 642, 643, 5, 73, 0, 0, 643, 644,
		3, 198, 99, 0, 644, 101, 1, 0, 0, 0, 645, 646, 3, 198, 99, 0, 646, 647,
		7, 2, 0, 0, 647, 103, 1, 0, 0, 0, 648, 649, 3, 62, 31, 0, 649, 650, 3,
		106, 53, 0, 650, 651, 3, 62, 31, 0, 651, 105, 1, 0, 0, 0, 652, 654, 7,
		3, 0, 0, 653, 652, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654, 655, 1, 0, 0,
		0, 655, 656, 5, 43, 0, 0, 656, 107, 1, 0, 0, 0, 657, 658, 3, 60, 30, 0,
		658, 659, 5, 50, 0, 0, 659, 660, 3, 62, 31, 0, 660, 109, 1, 0, 0, 0, 661,
		662, 5, 36, 0, 0, 662, 664, 5, 46, 0, 0, 663, 665, 3, 94, 47, 0, 664, 663,
		1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 111, 1, 0, 0, 0, 666, 668, 5, 21,
		0, 0, 667, 669, 3, 62, 31, 0, 668, 667, 1, 0, 0, 0, 668, 669, 1, 0, 0,
		0, 669, 113, 1, 0, 0, 0, 670, 672, 5, 1, 0, 0, 671, 673, 5, 36, 0, 0, 672,
		671, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673, 115, 1, 0, 0, 0, 674, 676,
		5, 5, 0, 0, 675, 677, 5, 36, 0, 0, 676, 675, 1, 0, 0, 0, 676, 677, 1, 0,
		0, 0, 677, 117, 1, 0, 0, 0, 678, 679, 5, 13, 0, 0, 679, 680, 5, 36, 0,
		0, 680, 119, 1, 0, 0, 0, 681, 682, 5, 9, 0, 0, 682, 121, 1, 0, 0, 0, 683,
		684, 5, 7, 0, 0, 684, 685, 3, 198, 99, 0, 685, 123, 1, 0, 0, 0, 686, 694,
		5, 14, 0, 0, 687, 695, 3, 198, 99, 0, 688, 689, 7, 4, 0, 0, 689, 695, 3,
		198, 99, 0, 690, 691, 3, 96, 48, 0, 691, 692, 7, 4, 0, 0, 692, 693, 3,
		198, 99, 0, 693, 695, 1, 0, 0, 0, 694, 687, 1, 0, 0, 0, 694, 688, 1, 0,
		0, 0, 694, 690, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 702, 3, 90, 45,
		0, 697, 700, 5, 8, 0, 0, 698, 701, 3, 124, 62, 0, 699, 701, 3, 90, 45,
		0, 700, 698, 1, 0, 0, 0, 700, 699, 1, 0, 0, 0, 701, 703, 1, 0, 0, 0, 702,
		697, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 125, 1, 0, 0, 0, 704, 707,
		3, 128, 64, 0, 705, 707, 3, 134, 67, 0, 706, 704, 1, 0, 0, 0, 706, 705,
		1, 0, 0, 0, 707, 127, 1, 0, 0, 0, 708, 719, 5, 24, 0, 0, 709, 711, 3, 198,
		99, 0, 710, 709, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711, 720, 1, 0, 0, 0,
		712, 714, 3, 96, 48, 0, 713, 712, 1, 0, 0, 0, 713, 714, 1, 0, 0, 0, 714,
		715, 1, 0, 0, 0, 715, 717, 3, 250, 125, 0, 716, 718, 3, 198, 99, 0, 717,
		716, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 720, 1, 0, 0, 0, 719, 710,
		1, 0, 0, 0, 719, 713, 1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 725, 5, 39,
		0, 0, 722, 724, 3, 130, 65, 0, 723, 722, 1, 0, 0, 0, 724, 727, 1, 0, 0,
		0, 725, 723, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 728, 1, 0, 0, 0, 727,
		725, 1, 0, 0, 0, 728, 729, 5, 40, 0, 0, 729, 129, 1, 0, 0, 0, 730, 731,
		3, 132, 66, 0, 731, 732, 5, 46, 0, 0, 732, 733, 3, 92, 46, 0, 733, 131,
		1, 0, 0, 0, 734, 735, 5, 2, 0, 0, 735, 738, 3, 62, 31, 0, 736, 738, 5,
		6, 0, 0, 737, 734, 1, 0, 0, 0, 737, 736, 1, 0, 0, 0, 738, 133, 1, 0, 0,
		0, 739, 748, 5, 24, 0, 0, 740, 749, 3, 136, 68, 0, 741, 742, 3, 250, 125,
		0, 742, 743, 3, 136, 68, 0, 743, 749, 1, 0, 0, 0, 744, 745, 3, 96, 48,
		0, 745, 746, 3, 250, 125, 0, 746, 747, 3, 136, 68, 0, 747, 749, 1, 0, 0,
		0, 748, 740, 1, 0, 0, 0, 748, 741, 1, 0, 0, 0, 748, 744, 1, 0, 0, 0, 749,
		750, 1, 0, 0, 0, 750, 754, 5, 39, 0, 0, 751, 753, 3, 138, 69, 0, 752, 751,
		1, 0, 0, 0, 753, 756, 1, 0, 0, 0, 754, 752, 1, 0, 0, 0, 754, 755, 1, 0,
		0, 0, 755, 757, 1, 0, 0, 0, 756, 754, 1, 0, 0, 0, 757, 758, 5, 40, 0, 0,
		758, 135, 1, 0, 0, 0, 759, 760, 5, 36, 0, 0, 760, 762, 5, 50, 0, 0, 761,
		759, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762, 763, 1, 0, 0, 0, 763, 764,
		3, 200, 100, 0, 764, 765, 5, 47, 0, 0, 765, 766, 5, 37, 0, 0, 766, 767,
		5, 25, 0, 0, 767, 768, 5, 38, 0, 0, 768, 137, 1, 0, 0, 0, 769, 770, 3,
		140, 70, 0, 770, 771, 5, 46, 0, 0, 771, 772, 3, 92, 46, 0, 772, 139, 1,
		0, 0, 0, 773, 774, 5, 2, 0, 0, 774, 777, 3, 142, 71, 0, 775, 777, 5, 6,
		0, 0, 776, 773, 1, 0, 0, 0, 776, 775, 1, 0, 0, 0, 777, 141, 1, 0, 0, 0,
		778, 781, 3, 162, 81, 0, 779, 781, 5, 18, 0, 0, 780, 778, 1, 0, 0, 0, 780,
		779, 1, 0, 0, 0, 781, 789, 1, 0, 0, 0, 782, 785, 5, 44, 0, 0, 783, 786,
		3, 162, 81, 0, 784, 786, 5, 18, 0, 0, 785, 783, 1, 0, 0, 0, 785, 784, 1,
		0, 0, 0, 786, 788, 1, 0, 0, 0, 787, 782, 1, 0, 0, 0, 788, 791, 1, 0, 0,
		0, 789, 787, 1, 0, 0, 0, 789, 790, 1, 0, 0, 0, 790, 143, 1, 0, 0, 0, 791,
		789, 1, 0, 0, 0, 792, 793, 5, 22, 0, 0, 793, 797, 5, 39, 0, 0, 794, 796,
		3, 146, 73, 0, 795, 794, 1, 0, 0, 0, 796, 799, 1, 0, 0, 0, 797, 795, 1,
		0, 0, 0, 797, 798, 1, 0, 0, 0, 798, 800, 1, 0, 0, 0, 799, 797, 1, 0, 0,
		0, 800, 801, 5, 40, 0, 0, 801, 145, 1, 0, 0, 0, 802, 803, 3, 148, 74, 0,
		803, 804, 5, 46, 0, 0, 804, 805, 3, 92, 46, 0, 805, 147, 1, 0, 0, 0, 806,
		809, 5, 2, 0, 0, 807, 810, 3, 100, 50, 0, 808, 810, 3, 150, 75, 0, 809,
		807, 1, 0, 0, 0, 809, 808, 1, 0, 0, 0, 810, 813, 1, 0, 0, 0, 811, 813,
		5, 6, 0, 0, 812, 806, 1, 0, 0, 0, 812, 811, 1, 0, 0, 0, 813, 149, 1, 0,
		0, 0, 814, 815, 3, 62, 31, 0, 815, 816, 5, 43, 0, 0, 816, 821, 1, 0, 0,
		0, 817, 818, 3, 60, 30, 0, 818, 819, 5, 50, 0, 0, 819, 821, 1, 0, 0, 0,
		820, 814, 1, 0, 0, 0, 820, 817, 1, 0, 0, 0, 820, 821, 1, 0, 0, 0, 821,
		822, 1, 0, 0, 0, 822, 823, 3, 198, 99, 0, 823, 151, 1, 0, 0, 0, 824, 828,
		5, 10, 0, 0, 825, 829, 3, 154, 77, 0, 826, 829, 3, 156, 78, 0, 827, 829,
		3, 158, 79, 0, 828, 825, 1, 0, 0, 0, 828, 826, 1, 0, 0, 0, 828, 827, 1,
		0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 830, 1, 0, 0, 0, 830, 831, 3, 90, 45,
		0, 831, 153, 1, 0, 0, 0, 832, 833, 3, 198, 99, 0, 833, 155, 1, 0, 0, 0,
		834, 836, 3, 96, 48, 0, 835, 834, 1, 0, 0, 0, 835, 836, 1, 0, 0, 0, 836,
		837, 1, 0, 0, 0, 837, 839, 3, 250, 125, 0, 838, 840, 3, 198, 99, 0, 839,
		838, 1, 0, 0, 0, 839, 840, 1, 0, 0, 0, 840, 841, 1, 0, 0, 0, 841, 843,
		3, 250, 125, 0, 842, 844, 3, 96, 48, 0, 843, 842, 1, 0, 0, 0, 843, 844,
		1, 0, 0, 0, 844, 157, 1, 0, 0, 0, 845, 846, 3, 62, 31, 0, 846, 847, 5,
		43, 0, 0, 847, 852, 1, 0, 0, 0, 848, 849, 3, 60, 30, 0, 849, 850, 5, 50,
		0, 0, 850, 852, 1, 0, 0, 0, 851, 845, 1, 0, 0, 0, 851, 848, 1, 0, 0, 0,
		851, 852, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 854, 5, 20, 0, 0, 854,
		855, 3, 198, 99, 0, 855, 159, 1, 0, 0, 0, 856, 857, 5, 12, 0, 0, 857, 858,
		3, 198, 99, 0, 858, 161, 1, 0, 0, 0, 859, 861, 3, 166, 83, 0, 860, 862,
		3, 164, 82, 0, 861, 860, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862, 869, 1,
		0, 0, 0, 863, 869, 3, 168, 84, 0, 864, 865, 5, 37, 0, 0, 865, 866, 3, 162,
		81, 0, 866, 867, 5, 38, 0, 0, 867, 869, 1, 0, 0, 0, 868, 859, 1, 0, 0,
		0, 868, 863, 1, 0, 0, 0, 868, 864, 1, 0, 0, 0, 869, 163, 1, 0, 0, 0, 870,
		871, 5, 41, 0, 0, 871, 873, 3, 142, 71, 0, 872, 874, 5, 44, 0, 0, 873,
		872, 1, 0, 0, 0, 873, 874, 1, 0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 876,
		5, 42, 0, 0, 876, 165, 1, 0, 0, 0, 877, 880, 3, 214, 107, 0, 878, 880,
		5, 36, 0, 0, 879, 877, 1, 0, 0, 0, 879, 878, 1, 0, 0, 0, 880, 167, 1, 0,
		0, 0, 881, 890, 3, 170, 85, 0, 882, 890, 3, 230, 115, 0, 883, 890, 3, 176,
		88, 0, 884, 890, 3, 188, 94, 0, 885, 890, 3, 178, 89, 0, 886, 890, 3, 180,
		90, 0, 887, 890, 3, 182, 91, 0, 888, 890, 3, 184, 92, 0, 889, 881, 1, 0,
		0, 0, 889, 882, 1, 0, 0, 0, 889, 883, 1, 0, 0, 0, 889, 884, 1, 0, 0, 0,
		889, 885, 1, 0, 0, 0, 889, 886, 1, 0, 0, 0, 889, 887, 1, 0, 0, 0, 889,
		888, 1, 0, 0, 0, 890, 169, 1, 0, 0, 0, 891, 892, 5, 41, 0, 0, 892, 893,
		3, 172, 86, 0, 893, 894, 5, 42, 0, 0, 894, 895, 3, 174, 87, 0, 895, 171,
		1, 0, 0, 0, 896, 897, 3, 198, 99, 0, 897, 173, 1, 0, 0, 0, 898, 899, 3,
		162, 81, 0, 899, 175, 1, 0, 0, 0, 900, 901, 5, 71, 0, 0, 901, 902, 3, 162,
		81, 0, 902, 177, 1, 0, 0, 0, 903, 904, 5, 16, 0, 0, 904, 913, 5, 39, 0,
		0, 905, 908, 3, 186, 93, 0, 906, 908, 3, 76, 38, 0, 907, 905, 1, 0, 0,
		0, 907, 906, 1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 910, 3, 250, 125, 0,
		910, 912, 1, 0, 0, 0, 911, 907, 1, 0, 0, 0, 912, 915, 1, 0, 0, 0, 913,
		911, 1, 0, 0, 0, 913, 914, 1, 0, 0, 0, 914, 916, 1, 0, 0, 0, 915, 913,
		1, 0, 0, 0, 916, 917, 5, 40, 0, 0, 917, 179, 1, 0, 0, 0, 918, 919, 5, 41,
		0, 0, 919, 920, 5, 42, 0, 0, 920, 921, 3, 174, 87, 0, 921, 181, 1, 0, 0,
		0, 922, 923, 5, 17, 0, 0, 923, 924, 5, 41, 0, 0, 924, 925, 3, 162, 81,
		0, 925, 926, 5, 42, 0, 0, 926, 927, 3, 174, 87, 0, 927, 183, 1, 0, 0, 0,
		928, 929, 4, 92, 0, 0, 929, 935, 5, 3, 0, 0, 930, 931, 5, 3, 0, 0, 931,
		935, 5, 73, 0, 0, 932, 933, 5, 73, 0, 0, 933, 935, 5, 3, 0, 0, 934, 928,
		1, 0, 0, 0, 934, 930, 1, 0, 0, 0, 934, 932, 1, 0, 0, 0, 935, 936, 1, 0,
		0, 0, 936, 937, 3, 174, 87, 0, 937, 185, 1, 0, 0, 0, 938, 939, 5, 36, 0,
		0, 939, 940, 3, 194, 97, 0, 940, 941, 3, 192, 96, 0, 941, 945, 1, 0, 0,
		0, 942, 943, 5, 36, 0, 0, 943, 945, 3, 194, 97, 0, 944, 938, 1, 0, 0, 0,
		944, 942, 1, 0, 0, 0, 945, 187, 1, 0, 0, 0, 946, 947, 5, 11, 0, 0, 947,
		948, 3, 190, 95, 0, 948, 189, 1, 0, 0, 0, 949, 951, 3, 194, 97, 0, 950,
		952, 3, 192, 96, 0, 951, 950, 1, 0, 0, 0, 951, 952, 1, 0, 0, 0, 952, 191,
		1, 0, 0, 0, 953, 956, 3, 194, 97, 0, 954, 956, 3, 162, 81, 0, 955, 953,
		1, 0, 0, 0, 955, 954, 1, 0, 0, 0, 956, 193, 1, 0, 0, 0, 957, 969, 5, 37,
		0, 0, 958, 963, 3, 196, 98, 0, 959, 960, 5, 44, 0, 0, 960, 962, 3, 196,
		98, 0, 961, 959, 1, 0, 0, 0, 962, 965, 1, 0, 0, 0, 963, 961, 1, 0, 0, 0,
		963, 964, 1, 0, 0, 0, 964, 967, 1, 0, 0, 0, 965, 963, 1, 0, 0, 0, 966,
		968, 5, 44, 0, 0, 967, 966, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 970,
		1, 0, 0, 0, 969, 958, 1, 0, 0, 0, 969, 970, 1, 0, 0, 0, 970, 971, 1, 0,
		0, 0, 971, 972, 5, 38, 0, 0, 972, 195, 1, 0, 0, 0, 973, 975, 3, 60, 30,
		0, 974, 973, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 977, 1, 0, 0, 0, 976,
		978, 5, 51, 0, 0, 977, 976, 1, 0, 0, 0, 977, 978, 1, 0, 0, 0, 978, 979,
		1, 0, 0, 0, 979, 980, 3, 162, 81, 0, 980, 197, 1, 0, 0, 0, 981, 982, 6,
		99, -1, 0, 982, 986, 3, 200, 100, 0, 983, 984, 7, 5, 0, 0, 984, 986, 3,
		198, 99, 6, 985, 981, 1, 0, 0, 0, 985, 983, 1, 0, 0, 0, 986, 1004, 1, 0,
		0, 0, 987, 988, 10, 5, 0, 0, 988, 989, 7, 6, 0, 0, 989, 1003, 3, 198, 99,
		6, 990, 991, 10, 4, 0, 0, 991, 992, 7, 7, 0, 0, 992, 1003, 3, 198, 99,
		5, 993, 994, 10, 3, 0, 0, 994, 995, 7, 8, 0, 0, 995, 1003, 3, 198, 99,
		4, 996, 997, 10, 2, 0, 0, 997, 998, 5, 53, 0, 0, 998, 1003, 3, 198, 99,
		3, 999, 1000, 10, 1, 0, 0, 1000, 1001, 5, 52, 0, 0, 1001, 1003, 3, 198,
		99, 2, 1002, 987, 1, 0, 0, 0, 1002, 990, 1, 0, 0, 0, 1002, 993, 1, 0, 0,
		0, 1002, 996, 1, 0, 0, 0, 1002, 999, 1, 0, 0, 0, 1003, 1006, 1, 0, 0, 0,
		1004, 1002, 1, 0, 0, 0, 1004, 1005, 1, 0, 0, 0, 1005, 199, 1, 0, 0, 0,
		1006, 1004, 1, 0, 0, 0, 1007, 1008, 4, 100, 6, 0, 1008, 1014, 3, 204, 102,
		0, 1009, 1010, 4, 100, 7, 0, 1010, 1014, 3, 202, 101, 0, 1011, 1012, 4,
		100, 8, 0, 1012, 1014, 3, 248, 124, 0, 1013, 1007, 1, 0, 0, 0, 1013, 1009,
		1, 0, 0, 0, 1013, 1011, 1, 0, 0, 0, 1014, 1023, 1, 0, 0, 0, 1015, 1016,
		5, 47, 0, 0, 1016, 1022, 5, 36, 0, 0, 1017, 1022, 3, 240, 120, 0, 1018,
		1022, 3, 242, 121, 0, 1019, 1022, 3, 244, 122, 0, 1020, 1022, 3, 246, 123,
		0, 1021, 1015, 1, 0, 0, 0, 1021, 1017, 1, 0, 0, 0, 1021, 1018, 1, 0, 0,
		0, 1021, 1019, 1, 0, 0, 0, 1021, 1020, 1, 0, 0, 0, 1022, 1025, 1, 0, 0,
		0, 1023, 1021, 1, 0, 0, 0, 1023, 1024, 1, 0, 0, 0, 1024, 201, 1, 0, 0,
		0, 1025, 1023, 1, 0, 0, 0, 1026, 1027, 3, 162, 81, 0, 1027, 1028, 5, 37,
		0, 0, 1028, 1030, 3, 198, 99, 0, 1029, 1031, 5, 44, 0, 0, 1030, 1029, 1,
		0, 0, 0, 1030, 1031, 1, 0, 0, 0, 1031, 1032, 1, 0, 0, 0, 1032, 1033, 5,
		38, 0, 0, 1033, 203, 1, 0, 0, 0, 1034, 1044, 3, 206, 103, 0, 1035, 1037,
		3, 212, 106, 0, 1036, 1038, 3, 164, 82, 0, 1037, 1036, 1, 0, 0, 0, 1037,
		1038, 1, 0, 0, 0, 1038, 1044, 1, 0, 0, 0, 1039, 1040, 5, 37, 0, 0, 1040,
		1041, 3, 198, 99, 0, 1041, 1042, 5, 38, 0, 0, 1042, 1044, 1, 0, 0, 0, 1043,
		1034, 1, 0, 0, 0, 1043, 1035, 1, 0, 0, 0, 1043, 1039, 1, 0, 0, 0, 1044,
		205, 1, 0, 0, 0, 1045, 1049, 3, 208, 104, 0, 1046, 1049, 3, 216, 108, 0,
		1047, 1049, 3, 238, 119, 0, 1048, 1045, 1, 0, 0, 0, 1048, 1046, 1, 0, 0,
		0, 1048, 1047, 1, 0, 0, 0, 1049, 207, 1, 0, 0, 0, 1050, 1055, 5, 18, 0,
		0, 1051, 1055, 3, 210, 105, 0, 1052, 1055, 3, 234, 117, 0, 1053, 1055,
		5, 80, 0, 0, 1054, 1050, 1, 0, 0, 0, 1054, 1051, 1, 0, 0, 0, 1054, 1052,
		1, 0, 0, 0, 1054, 1053, 1, 0, 0, 0, 1055, 209, 1, 0, 0, 0, 1056, 1057,
		7, 9, 0, 0, 1057, 211, 1, 0, 0, 0, 1058, 1061, 5, 36, 0, 0, 1059, 1061,
		3, 214, 107, 0, 1060, 1058, 1, 0, 0, 0, 1060, 1059, 1, 0, 0, 0, 1061, 213,
		1, 0, 0, 0, 1062, 1063, 5, 36, 0, 0, 1063, 1064, 5, 47, 0, 0, 1064, 1065,
		5, 36, 0, 0, 1065, 215, 1, 0, 0, 0, 1066, 1067, 3, 218, 109, 0, 1067, 1068,
		3, 220, 110, 0, 1068, 217, 1, 0, 0, 0, 1069, 1082, 3, 230, 115, 0, 1070,
		1082, 3, 170, 85, 0, 1071, 1072, 5, 41, 0, 0, 1072, 1073, 5, 51, 0, 0,
		1073, 1074, 5, 42, 0, 0, 1074, 1082, 3, 174, 87, 0, 1075, 1082, 3, 180,
		90, 0, 1076, 1082, 3, 182, 91, 0, 1077, 1079, 3, 166, 83, 0, 1078, 1080,
		3, 164, 82, 0, 1079, 1078, 1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080, 1082,
		1, 0, 0, 0, 1081, 1069, 1, 0, 0, 0, 1081, 1070, 1, 0, 0, 0, 1081, 1071,
		1, 0, 0, 0, 1081, 1075, 1, 0, 0, 0, 1081, 1076, 1, 0, 0, 0, 1081, 1077,
		1, 0, 0, 0, 1082, 219, 1, 0, 0, 0, 1083, 1088, 5, 39, 0, 0, 1084, 1086,
		3, 222, 111, 0, 1085, 1087, 5, 44, 0, 0, 1086, 1085, 1, 0, 0, 0, 1086,
		1087, 1, 0, 0, 0, 1087, 1089, 1, 0, 0, 0, 1088, 1084, 1, 0, 0, 0, 1088,
		1089, 1, 0, 0, 0, 1089, 1090, 1, 0, 0, 0, 1090, 1091, 5, 40, 0, 0, 1091,
		221, 1, 0, 0, 0, 1092, 1097, 3, 224, 112, 0, 1093, 1094, 5, 44, 0, 0, 1094,
		1096, 3, 224, 112, 0, 1095, 1093, 1, 0, 0, 0, 1096, 1099, 1, 0, 0, 0, 1097,
		1095, 1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0, 1098, 223, 1, 0, 0, 0, 1099,
		1097, 1, 0, 0, 0, 1100, 1101, 3, 226, 113, 0, 1101, 1102, 5, 46, 0, 0,
		1102, 1104, 1, 0, 0, 0, 1103, 1100, 1, 0, 0, 0, 1103, 1104, 1, 0, 0, 0,
		1104, 1105, 1, 0, 0, 0, 1105, 1106, 3, 228, 114, 0, 1106, 225, 1, 0, 0,
		0, 1107, 1110, 3, 198, 99, 0, 1108, 1110, 3, 220, 110, 0, 1109, 1107, 1,
		0, 0, 0, 1109, 1108, 1, 0, 0, 0, 1110, 227, 1, 0, 0, 0, 1111, 1114, 3,
		198, 99, 0, 1112, 1114, 3, 220, 110, 0, 1113, 1111, 1, 0, 0, 0, 1113, 1112,
		1, 0, 0, 0, 1114, 229, 1, 0, 0, 0, 1115, 1116, 5, 23, 0, 0, 1116, 1122,
		5, 39, 0, 0, 1117, 1118, 3, 232, 116, 0, 1118, 1119, 3, 250, 125, 0, 1119,
		1121, 1, 0, 0, 0, 1120, 1117, 1, 0, 0, 0, 1121, 1124, 1, 0, 0, 0, 1122,
		1120, 1, 0, 0, 0, 1122, 1123, 1, 0, 0, 0, 1123, 1125, 1, 0, 0, 0, 1124,
		1122, 1, 0, 0, 0, 1125, 1126, 5, 40, 0, 0, 1126, 231, 1, 0, 0, 0, 1127,
		1128, 3, 60, 30, 0, 1128, 1129, 3, 162, 81, 0, 1129, 1132, 1, 0, 0, 0,
		1130, 1132, 3, 236, 118, 0, 1131, 1127, 1, 0, 0, 0, 1131, 1130, 1, 0, 0,
		0, 1132, 1134, 1, 0, 0, 0, 1133, 1135, 3, 234, 117, 0, 1134, 1133, 1, 0,
		0, 0, 1134, 1135, 1, 0, 0, 0, 1135, 233, 1, 0, 0, 0, 1136, 1137, 7, 10,
		0, 0, 1137, 235, 1, 0, 0, 0, 1138, 1140, 5, 71, 0, 0, 1139, 1138, 1, 0,
		0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 1143, 3, 166,
		83, 0, 1142, 1144, 3, 164, 82, 0, 1143, 1142, 1, 0, 0, 0, 1143, 1144, 1,
		0, 0, 0, 1144, 237, 1, 0, 0, 0, 1145, 1146, 5, 11, 0, 0, 1146, 1147, 3,
		190, 95, 0, 1147, 1148, 3, 90, 45, 0, 1148, 239, 1, 0, 0, 0, 1149, 1150,
		5, 41, 0, 0, 1150, 1151, 3, 198, 99, 0, 1151, 1152, 5, 42, 0, 0, 1152,
		241, 1, 0, 0, 0, 1153, 1169, 5, 41, 0, 0, 1154, 1156, 3, 198, 99, 0, 1155,
		1154, 1, 0, 0, 0, 1155, 1156, 1, 0, 0, 0, 1156, 1157, 1, 0, 0, 0, 1157,
		1159, 5, 46, 0, 0, 1158, 1160, 3, 198, 99, 0, 1159, 1158, 1, 0, 0, 0, 1159,
		1160, 1, 0, 0, 0, 1160, 1170, 1, 0, 0, 0, 1161, 1163, 3, 198, 99, 0, 1162,
		1161, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164,
		1165, 5, 46, 0, 0, 1165, 1166, 3, 198, 99, 0, 1166, 1167, 5, 46, 0, 0,
		1167, 1168, 3, 198, 99, 0, 1168, 1170, 1, 0, 0, 0, 1169, 1155, 1, 0, 0,
		0, 1169, 1162, 1, 0, 0, 0, 1170, 1171, 1, 0, 0, 0, 1171, 1172, 5, 42, 0,
		0, 1172, 243, 1, 0, 0, 0, 1173, 1174, 5, 47, 0, 0, 1174, 1175, 5, 37, 0,
		0, 1175, 1176, 3, 162, 81, 0, 1176, 1177, 5, 38, 0, 0, 1177, 245, 1, 0,
		0, 0, 1178, 1193, 5, 37, 0, 0, 1179, 1186, 3, 62, 31, 0, 1180, 1183, 3,
		162, 81, 0, 1181, 1182, 5, 44, 0, 0, 1182, 1184, 3, 62, 31, 0, 1183, 1181,
		1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 1186, 1, 0, 0, 0, 1185, 1179,
		1, 0, 0, 0, 1185, 1180, 1, 0, 0, 0, 1186, 1188, 1, 0, 0, 0, 1187, 1189,
		5, 51, 0, 0, 1188, 1187, 1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1191,
		1, 0, 0, 0, 1190, 1192, 5, 44, 0, 0, 1191, 1190, 1, 0, 0, 0, 1191, 1192,
		1, 0, 0, 0, 1192, 1194, 1, 0, 0, 0, 1193, 1185, 1, 0, 0, 0, 1193, 1194,
		1, 0, 0, 0, 1194, 1195, 1, 0, 0, 0, 1195, 1196, 5, 38, 0, 0, 1196, 247,
		1, 0, 0, 0, 1197, 1198, 3, 162, 81, 0, 1198, 1199, 5, 47, 0, 0, 1199, 1200,
		5, 36, 0, 0, 1200, 249, 1, 0, 0, 0, 1201, 1205, 5, 45, 0, 0, 1202, 1205,
		5, 99, 0, 0, 1203, 1205, 4, 125, 9, 0, 1204, 1201, 1, 0, 0, 0, 1204, 1202,
		1, 0, 0, 0, 1204, 1203, 1, 0, 0, 0, 1205, 251, 1, 0, 0, 0, 131, 259, 267,
		276, 297, 307, 313, 320, 337, 346, 352, 361, 367, 371, 377, 381, 387, 391,
		397, 401, 408, 440, 444, 448, 458, 468, 472, 476, 480, 487, 495, 506, 510,
		514, 518, 525, 535, 548, 552, 559, 563, 570, 582, 586, 592, 596, 605, 612,
		630, 637, 653, 664, 668, 672, 676, 694, 700, 702, 706, 710, 713, 717, 719,
		725, 737, 748, 754, 761, 776, 780, 785, 789, 797, 809, 812, 820, 828, 835,
		839, 843, 851, 861, 868, 873, 879, 889, 907, 913, 934, 944, 951, 955, 963,
		967, 969, 974, 977, 985, 1002, 1004, 1013, 1021, 1023, 1030, 1037, 1043,
		1048, 1054, 1060, 1079, 1081, 1086, 1088, 1097, 1103, 1109, 1113, 1122,
		1131, 1134, 1139, 1143, 1155, 1159, 1162, 1169, 1183, 1185, 1188, 1191,
		1193, 1204,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ChainParserInit initializes any static state used to implement ChainParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewChainParser(). You can call p function if you wish to initialize the static state ahead
// of time.
func ChainParserInit() {
	staticData := &ChainParserParserStaticData
	staticData.once.Do(chainparserParserInit)
}

// NewChainParser produces a new parser instance for the optional input antlr.TokenStream.
func NewChainParser(input antlr.TokenStream) *ChainParser {
	ChainParserInit()
	p := new(ChainParser)
	p.BaseParser = antlr.NewBaseParser(input)
	staticData := &ChainParserParserStaticData
	p.Interpreter = antlr.NewParserATNSimulator(p, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	p.RuleNames = staticData.RuleNames
	p.LiteralNames = staticData.LiteralNames
	p.SymbolicNames = staticData.SymbolicNames
	p.GrammarFileName = "ChainParser.g4"

	return p
}

// ChainParser tokens.
const (
	ChainParserEOF                    = antlr.TokenEOF
	ChainParserBREAK                  = 1
	ChainParserCASE                   = 2
	ChainParserCHAN                   = 3
	ChainParserCONST                  = 4
	ChainParserCONTINUE               = 5
	ChainParserDEFAULT                = 6
	ChainParserDEFER                  = 7
	ChainParserELSE                   = 8
	ChainParserFALLTHROUGH            = 9
	ChainParserFOR                    = 10
	ChainParserFUNC                   = 11
	ChainParserGO                     = 12
	ChainParserGOTO                   = 13
	ChainParserIF                     = 14
	ChainParserIMPORT                 = 15
	ChainParserINTERFACE              = 16
	ChainParserMAP                    = 17
	ChainParserNIL_LIT                = 18
	ChainParserPACKAGE                = 19
	ChainParserRANGE                  = 20
	ChainParserRETURN                 = 21
	ChainParserSELECT                 = 22
	ChainParserSTRUCT                 = 23
	ChainParserSWITCH                 = 24
	ChainParserTYPE                   = 25
	ChainParserVAR                    = 26
	ChainParserWORKFLOW               = 27
	ChainParserGENERATES              = 28
	ChainParserPREREQUISITE           = 29
	ChainParserNODES                  = 30
	ChainParserBRANCHES               = 31
	ChainParserSUCCESS                = 32
	ChainParserERROR                  = 33
	ChainParserABORT                  = 34
	ChainParserEND                    = 35
	ChainParserIDENTIFIER             = 36
	ChainParserL_PAREN                = 37
	ChainParserR_PAREN                = 38
	ChainParserL_CURLY                = 39
	ChainParserR_CURLY                = 40
	ChainParserL_BRACKET              = 41
	ChainParserR_BRACKET              = 42
	ChainParserASSIGN                 = 43
	ChainParserCOMMA                  = 44
	ChainParserSEMI                   = 45
	ChainParserCOLON                  = 46
	ChainParserDOT                    = 47
	ChainParserPLUS_PLUS              = 48
	ChainParserMINUS_MINUS            = 49
	ChainParserDECLARE_ASSIGN         = 50
	ChainParserELLIPSIS               = 51
	ChainParserLOGICAL_OR             = 52
	ChainParserLOGICAL_AND            = 53
	ChainParserEQUALS                 = 54
	ChainParserNOT_EQUALS             = 55
	ChainParserLESS                   = 56
	ChainParserLESS_OR_EQUALS         = 57
	ChainParserGREATER                = 58
	ChainParserGREATER_OR_EQUALS      = 59
	ChainParserOR                     = 60
	ChainParserDIV                    = 61
	ChainParserMOD                    = 62
	ChainParserLSHIFT                 = 63
	ChainParserRSHIFT                 = 64
	ChainParserBIT_CLEAR              = 65
	ChainParserUNDERLYING             = 66
	ChainParserEXCLAMATION            = 67
	ChainParserPLUS                   = 68
	ChainParserMINUS                  = 69
	ChainParserCARET                  = 70
	ChainParserSTAR                   = 71
	ChainParserAMPERSAND              = 72
	ChainParserRECEIVE                = 73
	ChainParserL_TO_R                 = 74
	ChainParserR_TO_L                 = 75
	ChainParserDECIMAL_LIT            = 76
	ChainParserBINARY_LIT             = 77
	ChainParserOCTAL_LIT              = 78
	ChainParserHEX_LIT                = 79
	ChainParserFLOAT_LIT              = 80
	ChainParserDECIMAL_FLOAT_LIT      = 81
	ChainParserHEX_FLOAT_LIT          = 82
	ChainParserIMAGINARY_LIT          = 83
	ChainParserRUNE_LIT               = 84
	ChainParserBYTE_VALUE             = 85
	ChainParserOCTAL_BYTE_VALUE       = 86
	ChainParserHEX_BYTE_VALUE         = 87
	ChainParserLITTLE_U_VALUE         = 88
	ChainParserBIG_U_VALUE            = 89
	ChainParserRAW_STRING_LIT         = 90
	ChainParserINTERPRETED_STRING_LIT = 91
	ChainParserWS                     = 92
	ChainParserCOMMENT                = 93
	ChainParserTERMINATOR             = 94
	ChainParserLINE_COMMENT           = 95
	ChainParserWS_NLSEMI              = 96
	ChainParserCOMMENT_NLSEMI         = 97
	ChainParserLINE_COMMENT_NLSEMI    = 98
	ChainParserEOS                    = 99
	ChainParserOTHER                  = 100
)

// ChainParser rules.
const (
	ChainParserRULE_sourceFile            = 0
	ChainParserRULE_workflowDecl          = 1
	ChainParserRULE_workflowConstruct     = 2
	ChainParserRULE_workflowSpec          = 3
	ChainParserRULE_workflowBlock         = 4
	ChainParserRULE_workflowStatementList = 5
	ChainParserRULE_prerequisteStatements = 6
	ChainParserRULE_prerequisiteStmt      = 7
	ChainParserRULE_golangEmbedStatement  = 8
	ChainParserRULE_nodesStatements       = 9
	ChainParserRULE_nodeStmt              = 10
	ChainParserRULE_directionStatements   = 11
	ChainParserRULE_successStatements     = 12
	ChainParserRULE_errorStatements       = 13
	ChainParserRULE_abortStatements       = 14
	ChainParserRULE_branchesStatements    = 15
	ChainParserRULE_directionStmt         = 16
	ChainParserRULE_nodeName              = 17
	ChainParserRULE_branchStmt            = 18
	ChainParserRULE_branchDirection       = 19
	ChainParserRULE_chain_eos             = 20
	ChainParserRULE_packageClause         = 21
	ChainParserRULE_packageName           = 22
	ChainParserRULE_identifier            = 23
	ChainParserRULE_importDecl            = 24
	ChainParserRULE_importSpec            = 25
	ChainParserRULE_importPath            = 26
	ChainParserRULE_declaration           = 27
	ChainParserRULE_constDecl             = 28
	ChainParserRULE_constSpec             = 29
	ChainParserRULE_identifierList        = 30
	ChainParserRULE_expressionList        = 31
	ChainParserRULE_typeDecl              = 32
	ChainParserRULE_typeSpec              = 33
	ChainParserRULE_aliasDecl             = 34
	ChainParserRULE_typeDef               = 35
	ChainParserRULE_typeParameters        = 36
	ChainParserRULE_typeParameterDecl     = 37
	ChainParserRULE_typeElement           = 38
	ChainParserRULE_typeTerm              = 39
	ChainParserRULE_functionDecl          = 40
	ChainParserRULE_methodDecl            = 41
	ChainParserRULE_receiver              = 42
	ChainParserRULE_varDecl               = 43
	ChainParserRULE_varSpec               = 44
	ChainParserRULE_block                 = 45
	ChainParserRULE_statementList         = 46
	ChainParserRULE_statement             = 47
	ChainParserRULE_simpleStmt            = 48
	ChainParserRULE_expressionStmt        = 49
	ChainParserRULE_sendStmt              = 50
	ChainParserRULE_incDecStmt            = 51
	ChainParserRULE_assignment            = 52
	ChainParserRULE_assign_op             = 53
	ChainParserRULE_shortVarDecl          = 54
	ChainParserRULE_labeledStmt           = 55
	ChainParserRULE_returnStmt            = 56
	ChainParserRULE_breakStmt             = 57
	ChainParserRULE_continueStmt          = 58
	ChainParserRULE_gotoStmt              = 59
	ChainParserRULE_fallthroughStmt       = 60
	ChainParserRULE_deferStmt             = 61
	ChainParserRULE_ifStmt                = 62
	ChainParserRULE_switchStmt            = 63
	ChainParserRULE_exprSwitchStmt        = 64
	ChainParserRULE_exprCaseClause        = 65
	ChainParserRULE_exprSwitchCase        = 66
	ChainParserRULE_typeSwitchStmt        = 67
	ChainParserRULE_typeSwitchGuard       = 68
	ChainParserRULE_typeCaseClause        = 69
	ChainParserRULE_typeSwitchCase        = 70
	ChainParserRULE_typeList              = 71
	ChainParserRULE_selectStmt            = 72
	ChainParserRULE_commClause            = 73
	ChainParserRULE_commCase              = 74
	ChainParserRULE_recvStmt              = 75
	ChainParserRULE_forStmt               = 76
	ChainParserRULE_condition             = 77
	ChainParserRULE_forClause             = 78
	ChainParserRULE_rangeClause           = 79
	ChainParserRULE_goStmt                = 80
	ChainParserRULE_type_                 = 81
	ChainParserRULE_typeArgs              = 82
	ChainParserRULE_typeName              = 83
	ChainParserRULE_typeLit               = 84
	ChainParserRULE_arrayType             = 85
	ChainParserRULE_arrayLength           = 86
	ChainParserRULE_elementType           = 87
	ChainParserRULE_pointerType           = 88
	ChainParserRULE_interfaceType         = 89
	ChainParserRULE_sliceType             = 90
	ChainParserRULE_mapType               = 91
	ChainParserRULE_channelType           = 92
	ChainParserRULE_methodSpec            = 93
	ChainParserRULE_functionType          = 94
	ChainParserRULE_signature             = 95
	ChainParserRULE_result                = 96
	ChainParserRULE_parameters            = 97
	ChainParserRULE_parameterDecl         = 98
	ChainParserRULE_expression            = 99
	ChainParserRULE_primaryExpr           = 100
	ChainParserRULE_conversion            = 101
	ChainParserRULE_operand               = 102
	ChainParserRULE_literal               = 103
	ChainParserRULE_basicLit              = 104
	ChainParserRULE_integer               = 105
	ChainParserRULE_operandName           = 106
	ChainParserRULE_qualifiedIdent        = 107
	ChainParserRULE_compositeLit          = 108
	ChainParserRULE_literalType           = 109
	ChainParserRULE_literalValue          = 110
	ChainParserRULE_elementList           = 111
	ChainParserRULE_keyedElement          = 112
	ChainParserRULE_key                   = 113
	ChainParserRULE_element               = 114
	ChainParserRULE_structType            = 115
	ChainParserRULE_fieldDecl             = 116
	ChainParserRULE_string_               = 117
	ChainParserRULE_embeddedField         = 118
	ChainParserRULE_functionLit           = 119
	ChainParserRULE_index                 = 120
	ChainParserRULE_slice_                = 121
	ChainParserRULE_typeAssertion         = 122
	ChainParserRULE_arguments             = 123
	ChainParserRULE_methodExpr            = 124
	ChainParserRULE_eos                   = 125
)

// ISourceFileContext is an interface to support dynamic dispatch.
type ISourceFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageClause() IPackageClauseContext
	AllEos() []IEosContext
	Eos(i int) IEosContext
	EOF() antlr.TerminalNode
	AllImportDecl() []IImportDeclContext
	ImportDecl(i int) IImportDeclContext
	AllWorkflowDecl() []IWorkflowDeclContext
	WorkflowDecl(i int) IWorkflowDeclContext

	// IsSourceFileContext differentiates from other interfaces.
	IsSourceFileContext()
}

type SourceFileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceFileContext() *SourceFileContext {
	var p = new(SourceFileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_sourceFile
	return p
}

func InitEmptySourceFileContext(p *SourceFileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_sourceFile
}

func (*SourceFileContext) IsSourceFileContext() {}

func NewSourceFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceFileContext {
	var p = new(SourceFileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_sourceFile

	return p
}

func (s *SourceFileContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceFileContext) PackageClause() IPackageClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageClauseContext)
}

func (s *SourceFileContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *SourceFileContext) EOF() antlr.TerminalNode {
	return s.GetToken(ChainParserEOF, 0)
}

func (s *SourceFileContext) AllImportDecl() []IImportDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclContext); ok {
			tst[i] = t.(IImportDeclContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) ImportDecl(i int) IImportDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclContext)
}

func (s *SourceFileContext) AllWorkflowDecl() []IWorkflowDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWorkflowDeclContext); ok {
			len++
		}
	}

	tst := make([]IWorkflowDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWorkflowDeclContext); ok {
			tst[i] = t.(IWorkflowDeclContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) WorkflowDecl(i int) IWorkflowDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkflowDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkflowDeclContext)
}

func (s *SourceFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterSourceFile(s)
	}
}

func (s *SourceFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitSourceFile(s)
	}
}

func (s *SourceFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitSourceFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) SourceFile() (localctx ISourceFileContext) {
	localctx = NewSourceFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ChainParserRULE_sourceFile)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(252)
		p.PackageClause()
	}
	{
		p.SetState(253)
		p.Eos()
	}
	p.SetState(259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserIMPORT {
		{
			p.SetState(254)
			p.ImportDecl()
		}
		{
			p.SetState(255)
			p.Eos()
		}

		p.SetState(261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserWORKFLOW {
		{
			p.SetState(262)
			p.WorkflowDecl()
		}
		{
			p.SetState(263)
			p.Eos()
		}

		p.SetState(269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(270)
		p.Match(ChainParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkflowDeclContext is an interface to support dynamic dispatch.
type IWorkflowDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WORKFLOW() antlr.TerminalNode
	WorkflowConstruct() IWorkflowConstructContext
	Parameters() IParametersContext
	WorkflowSpec() IWorkflowSpecContext
	WorkflowBlock() IWorkflowBlockContext
	GENERATES() antlr.TerminalNode

	// IsWorkflowDeclContext differentiates from other interfaces.
	IsWorkflowDeclContext()
}

type WorkflowDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkflowDeclContext() *WorkflowDeclContext {
	var p = new(WorkflowDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowDecl
	return p
}

func InitEmptyWorkflowDeclContext(p *WorkflowDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowDecl
}

func (*WorkflowDeclContext) IsWorkflowDeclContext() {}

func NewWorkflowDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkflowDeclContext {
	var p = new(WorkflowDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_workflowDecl

	return p
}

func (s *WorkflowDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkflowDeclContext) WORKFLOW() antlr.TerminalNode {
	return s.GetToken(ChainParserWORKFLOW, 0)
}

func (s *WorkflowDeclContext) WorkflowConstruct() IWorkflowConstructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkflowConstructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkflowConstructContext)
}

func (s *WorkflowDeclContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *WorkflowDeclContext) WorkflowSpec() IWorkflowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkflowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkflowSpecContext)
}

func (s *WorkflowDeclContext) WorkflowBlock() IWorkflowBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkflowBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkflowBlockContext)
}

func (s *WorkflowDeclContext) GENERATES() antlr.TerminalNode {
	return s.GetToken(ChainParserGENERATES, 0)
}

func (s *WorkflowDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkflowDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkflowDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterWorkflowDecl(s)
	}
}

func (s *WorkflowDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitWorkflowDecl(s)
	}
}

func (s *WorkflowDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitWorkflowDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) WorkflowDecl() (localctx IWorkflowDeclContext) {
	localctx = NewWorkflowDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ChainParserRULE_workflowDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(272)
		p.Match(ChainParserWORKFLOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(273)
		p.WorkflowConstruct()
	}
	{
		p.SetState(274)
		p.Parameters()
	}
	p.SetState(276)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ChainParserGENERATES {
		{
			p.SetState(275)
			p.Match(ChainParserGENERATES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(278)
		p.WorkflowSpec()
	}
	{
		p.SetState(279)
		p.WorkflowBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkflowConstructContext is an interface to support dynamic dispatch.
type IWorkflowConstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsWorkflowConstructContext differentiates from other interfaces.
	IsWorkflowConstructContext()
}

type WorkflowConstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkflowConstructContext() *WorkflowConstructContext {
	var p = new(WorkflowConstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowConstruct
	return p
}

func InitEmptyWorkflowConstructContext(p *WorkflowConstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowConstruct
}

func (*WorkflowConstructContext) IsWorkflowConstructContext() {}

func NewWorkflowConstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkflowConstructContext {
	var p = new(WorkflowConstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_workflowConstruct

	return p
}

func (s *WorkflowConstructContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkflowConstructContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *WorkflowConstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkflowConstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkflowConstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterWorkflowConstruct(s)
	}
}

func (s *WorkflowConstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitWorkflowConstruct(s)
	}
}

func (s *WorkflowConstructContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitWorkflowConstruct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) WorkflowConstruct() (localctx IWorkflowConstructContext) {
	localctx = NewWorkflowConstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ChainParserRULE_workflowConstruct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(281)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkflowSpecContext is an interface to support dynamic dispatch.
type IWorkflowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	L_BRACKET() antlr.TerminalNode
	TypeElement() ITypeElementContext
	R_BRACKET() antlr.TerminalNode

	// IsWorkflowSpecContext differentiates from other interfaces.
	IsWorkflowSpecContext()
}

type WorkflowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkflowSpecContext() *WorkflowSpecContext {
	var p = new(WorkflowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowSpec
	return p
}

func InitEmptyWorkflowSpecContext(p *WorkflowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowSpec
}

func (*WorkflowSpecContext) IsWorkflowSpecContext() {}

func NewWorkflowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkflowSpecContext {
	var p = new(WorkflowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_workflowSpec

	return p
}

func (s *WorkflowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkflowSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *WorkflowSpecContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserL_BRACKET, 0)
}

func (s *WorkflowSpecContext) TypeElement() ITypeElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeElementContext)
}

func (s *WorkflowSpecContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserR_BRACKET, 0)
}

func (s *WorkflowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkflowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkflowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterWorkflowSpec(s)
	}
}

func (s *WorkflowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitWorkflowSpec(s)
	}
}

func (s *WorkflowSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitWorkflowSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) WorkflowSpec() (localctx IWorkflowSpecContext) {
	localctx = NewWorkflowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ChainParserRULE_workflowSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(284)
		p.Match(ChainParserL_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(285)
		p.TypeElement()
	}
	{
		p.SetState(286)
		p.Match(ChainParserR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkflowBlockContext is an interface to support dynamic dispatch.
type IWorkflowBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_CURLY() antlr.TerminalNode
	WorkflowStatementList() IWorkflowStatementListContext
	R_CURLY() antlr.TerminalNode

	// IsWorkflowBlockContext differentiates from other interfaces.
	IsWorkflowBlockContext()
}

type WorkflowBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkflowBlockContext() *WorkflowBlockContext {
	var p = new(WorkflowBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowBlock
	return p
}

func InitEmptyWorkflowBlockContext(p *WorkflowBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowBlock
}

func (*WorkflowBlockContext) IsWorkflowBlockContext() {}

func NewWorkflowBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkflowBlockContext {
	var p = new(WorkflowBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_workflowBlock

	return p
}

func (s *WorkflowBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkflowBlockContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserL_CURLY, 0)
}

func (s *WorkflowBlockContext) WorkflowStatementList() IWorkflowStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkflowStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkflowStatementListContext)
}

func (s *WorkflowBlockContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserR_CURLY, 0)
}

func (s *WorkflowBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkflowBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkflowBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterWorkflowBlock(s)
	}
}

func (s *WorkflowBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitWorkflowBlock(s)
	}
}

func (s *WorkflowBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitWorkflowBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) WorkflowBlock() (localctx IWorkflowBlockContext) {
	localctx = NewWorkflowBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ChainParserRULE_workflowBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(288)
		p.Match(ChainParserL_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(289)
		p.WorkflowStatementList()
	}
	{
		p.SetState(290)
		p.Match(ChainParserR_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkflowStatementListContext is an interface to support dynamic dispatch.
type IWorkflowStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrerequisteStatements() IPrerequisteStatementsContext
	NodesStatements() INodesStatementsContext
	AllDirectionStatements() []IDirectionStatementsContext
	DirectionStatements(i int) IDirectionStatementsContext

	// IsWorkflowStatementListContext differentiates from other interfaces.
	IsWorkflowStatementListContext()
}

type WorkflowStatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkflowStatementListContext() *WorkflowStatementListContext {
	var p = new(WorkflowStatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowStatementList
	return p
}

func InitEmptyWorkflowStatementListContext(p *WorkflowStatementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_workflowStatementList
}

func (*WorkflowStatementListContext) IsWorkflowStatementListContext() {}

func NewWorkflowStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkflowStatementListContext {
	var p = new(WorkflowStatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_workflowStatementList

	return p
}

func (s *WorkflowStatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkflowStatementListContext) PrerequisteStatements() IPrerequisteStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrerequisteStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrerequisteStatementsContext)
}

func (s *WorkflowStatementListContext) NodesStatements() INodesStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodesStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodesStatementsContext)
}

func (s *WorkflowStatementListContext) AllDirectionStatements() []IDirectionStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectionStatementsContext); ok {
			len++
		}
	}

	tst := make([]IDirectionStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectionStatementsContext); ok {
			tst[i] = t.(IDirectionStatementsContext)
			i++
		}
	}

	return tst
}

func (s *WorkflowStatementListContext) DirectionStatements(i int) IDirectionStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionStatementsContext)
}

func (s *WorkflowStatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkflowStatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkflowStatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterWorkflowStatementList(s)
	}
}

func (s *WorkflowStatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitWorkflowStatementList(s)
	}
}

func (s *WorkflowStatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitWorkflowStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) WorkflowStatementList() (localctx IWorkflowStatementListContext) {
	localctx = NewWorkflowStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ChainParserRULE_workflowStatementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(292)
		p.PrerequisteStatements()
	}
	{
		p.SetState(293)
		p.NodesStatements()
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&32212254720) != 0 {
		{
			p.SetState(294)
			p.DirectionStatements()
		}

		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrerequisteStatementsContext is an interface to support dynamic dispatch.
type IPrerequisteStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREREQUISITE() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	PrerequisiteStmt() IPrerequisiteStmtContext
	R_CURLY() antlr.TerminalNode
	AllEOS() []antlr.TerminalNode
	EOS(i int) antlr.TerminalNode

	// IsPrerequisteStatementsContext differentiates from other interfaces.
	IsPrerequisteStatementsContext()
}

type PrerequisteStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrerequisteStatementsContext() *PrerequisteStatementsContext {
	var p = new(PrerequisteStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_prerequisteStatements
	return p
}

func InitEmptyPrerequisteStatementsContext(p *PrerequisteStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_prerequisteStatements
}

func (*PrerequisteStatementsContext) IsPrerequisteStatementsContext() {}

func NewPrerequisteStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrerequisteStatementsContext {
	var p = new(PrerequisteStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_prerequisteStatements

	return p
}

func (s *PrerequisteStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *PrerequisteStatementsContext) PREREQUISITE() antlr.TerminalNode {
	return s.GetToken(ChainParserPREREQUISITE, 0)
}

func (s *PrerequisteStatementsContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserL_CURLY, 0)
}

func (s *PrerequisteStatementsContext) PrerequisiteStmt() IPrerequisiteStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrerequisiteStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrerequisiteStmtContext)
}

func (s *PrerequisteStatementsContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserR_CURLY, 0)
}

func (s *PrerequisteStatementsContext) AllEOS() []antlr.TerminalNode {
	return s.GetTokens(ChainParserEOS)
}

func (s *PrerequisteStatementsContext) EOS(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserEOS, i)
}

func (s *PrerequisteStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrerequisteStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrerequisteStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterPrerequisteStatements(s)
	}
}

func (s *PrerequisteStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitPrerequisteStatements(s)
	}
}

func (s *PrerequisteStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitPrerequisteStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) PrerequisteStatements() (localctx IPrerequisteStatementsContext) {
	localctx = NewPrerequisteStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ChainParserRULE_prerequisteStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.Match(ChainParserPREREQUISITE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(301)
		p.Match(ChainParserL_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(302)
		p.PrerequisiteStmt()
	}
	{
		p.SetState(303)
		p.Match(ChainParserR_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserEOS {
		{
			p.SetState(304)
			p.Match(ChainParserEOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrerequisiteStmtContext is an interface to support dynamic dispatch.
type IPrerequisiteStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGolangEmbedStatement() []IGolangEmbedStatementContext
	GolangEmbedStatement(i int) IGolangEmbedStatementContext
	AllEos() []IEosContext
	Eos(i int) IEosContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllEOS() []antlr.TerminalNode
	EOS(i int) antlr.TerminalNode

	// IsPrerequisiteStmtContext differentiates from other interfaces.
	IsPrerequisiteStmtContext()
}

type PrerequisiteStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrerequisiteStmtContext() *PrerequisiteStmtContext {
	var p = new(PrerequisiteStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_prerequisiteStmt
	return p
}

func InitEmptyPrerequisiteStmtContext(p *PrerequisiteStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_prerequisiteStmt
}

func (*PrerequisiteStmtContext) IsPrerequisiteStmtContext() {}

func NewPrerequisiteStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrerequisiteStmtContext {
	var p = new(PrerequisiteStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_prerequisiteStmt

	return p
}

func (s *PrerequisiteStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PrerequisiteStmtContext) AllGolangEmbedStatement() []IGolangEmbedStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGolangEmbedStatementContext); ok {
			len++
		}
	}

	tst := make([]IGolangEmbedStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGolangEmbedStatementContext); ok {
			tst[i] = t.(IGolangEmbedStatementContext)
			i++
		}
	}

	return tst
}

func (s *PrerequisiteStmtContext) GolangEmbedStatement(i int) IGolangEmbedStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGolangEmbedStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGolangEmbedStatementContext)
}

func (s *PrerequisiteStmtContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *PrerequisiteStmtContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *PrerequisiteStmtContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(ChainParserSEMI)
}

func (s *PrerequisiteStmtContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserSEMI, i)
}

func (s *PrerequisiteStmtContext) AllEOS() []antlr.TerminalNode {
	return s.GetTokens(ChainParserEOS)
}

func (s *PrerequisiteStmtContext) EOS(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserEOS, i)
}

func (s *PrerequisiteStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrerequisiteStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrerequisiteStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterPrerequisiteStmt(s)
	}
}

func (s *PrerequisiteStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitPrerequisiteStmt(s)
	}
}

func (s *PrerequisiteStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitPrerequisiteStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) PrerequisiteStmt() (localctx IPrerequisiteStmtContext) {
	localctx = NewPrerequisiteStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ChainParserRULE_prerequisiteStmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(313)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(310)
					p.Match(ChainParserSEMI)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				{
					p.SetState(311)
					p.Match(ChainParserEOS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(315)
				p.GolangEmbedStatement()
			}
			{
				p.SetState(316)
				p.Eos()
			}

		}
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGolangEmbedStatementContext is an interface to support dynamic dispatch.
type IGolangEmbedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	LabeledStmt() ILabeledStmtContext
	SimpleStmt() ISimpleStmtContext
	GoStmt() IGoStmtContext
	BreakStmt() IBreakStmtContext
	ContinueStmt() IContinueStmtContext
	GotoStmt() IGotoStmtContext
	FallthroughStmt() IFallthroughStmtContext
	Block() IBlockContext
	IfStmt() IIfStmtContext
	SwitchStmt() ISwitchStmtContext
	SelectStmt() ISelectStmtContext
	ForStmt() IForStmtContext
	DeferStmt() IDeferStmtContext

	// IsGolangEmbedStatementContext differentiates from other interfaces.
	IsGolangEmbedStatementContext()
}

type GolangEmbedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGolangEmbedStatementContext() *GolangEmbedStatementContext {
	var p = new(GolangEmbedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_golangEmbedStatement
	return p
}

func InitEmptyGolangEmbedStatementContext(p *GolangEmbedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_golangEmbedStatement
}

func (*GolangEmbedStatementContext) IsGolangEmbedStatementContext() {}

func NewGolangEmbedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GolangEmbedStatementContext {
	var p = new(GolangEmbedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_golangEmbedStatement

	return p
}

func (s *GolangEmbedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GolangEmbedStatementContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *GolangEmbedStatementContext) LabeledStmt() ILabeledStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledStmtContext)
}

func (s *GolangEmbedStatementContext) SimpleStmt() ISimpleStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *GolangEmbedStatementContext) GoStmt() IGoStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGoStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGoStmtContext)
}

func (s *GolangEmbedStatementContext) BreakStmt() IBreakStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStmtContext)
}

func (s *GolangEmbedStatementContext) ContinueStmt() IContinueStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStmtContext)
}

func (s *GolangEmbedStatementContext) GotoStmt() IGotoStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStmtContext)
}

func (s *GolangEmbedStatementContext) FallthroughStmt() IFallthroughStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFallthroughStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFallthroughStmtContext)
}

func (s *GolangEmbedStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *GolangEmbedStatementContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *GolangEmbedStatementContext) SwitchStmt() ISwitchStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStmtContext)
}

func (s *GolangEmbedStatementContext) SelectStmt() ISelectStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStmtContext)
}

func (s *GolangEmbedStatementContext) ForStmt() IForStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStmtContext)
}

func (s *GolangEmbedStatementContext) DeferStmt() IDeferStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStmtContext)
}

func (s *GolangEmbedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GolangEmbedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GolangEmbedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterGolangEmbedStatement(s)
	}
}

func (s *GolangEmbedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitGolangEmbedStatement(s)
	}
}

func (s *GolangEmbedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitGolangEmbedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) GolangEmbedStatement() (localctx IGolangEmbedStatementContext) {
	localctx = NewGolangEmbedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ChainParserRULE_golangEmbedStatement)
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(323)
			p.Declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(324)
			p.LabeledStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(325)
			p.SimpleStmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(326)
			p.GoStmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(327)
			p.BreakStmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(328)
			p.ContinueStmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(329)
			p.GotoStmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(330)
			p.FallthroughStmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(331)
			p.Block()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(332)
			p.IfStmt()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(333)
			p.SwitchStmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(334)
			p.SelectStmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(335)
			p.ForStmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(336)
			p.DeferStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodesStatementsContext is an interface to support dynamic dispatch.
type INodesStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NODES() antlr.TerminalNode
	COLON() antlr.TerminalNode
	AllNodeStmt() []INodeStmtContext
	NodeStmt(i int) INodeStmtContext
	AllEos() []IEosContext
	Eos(i int) IEosContext
	AllEOS() []antlr.TerminalNode
	EOS(i int) antlr.TerminalNode

	// IsNodesStatementsContext differentiates from other interfaces.
	IsNodesStatementsContext()
}

type NodesStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodesStatementsContext() *NodesStatementsContext {
	var p = new(NodesStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_nodesStatements
	return p
}

func InitEmptyNodesStatementsContext(p *NodesStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_nodesStatements
}

func (*NodesStatementsContext) IsNodesStatementsContext() {}

func NewNodesStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodesStatementsContext {
	var p = new(NodesStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_nodesStatements

	return p
}

func (s *NodesStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *NodesStatementsContext) NODES() antlr.TerminalNode {
	return s.GetToken(ChainParserNODES, 0)
}

func (s *NodesStatementsContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *NodesStatementsContext) AllNodeStmt() []INodeStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INodeStmtContext); ok {
			len++
		}
	}

	tst := make([]INodeStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INodeStmtContext); ok {
			tst[i] = t.(INodeStmtContext)
			i++
		}
	}

	return tst
}

func (s *NodesStatementsContext) NodeStmt(i int) INodeStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeStmtContext)
}

func (s *NodesStatementsContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *NodesStatementsContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *NodesStatementsContext) AllEOS() []antlr.TerminalNode {
	return s.GetTokens(ChainParserEOS)
}

func (s *NodesStatementsContext) EOS(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserEOS, i)
}

func (s *NodesStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodesStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodesStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterNodesStatements(s)
	}
}

func (s *NodesStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitNodesStatements(s)
	}
}

func (s *NodesStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitNodesStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) NodesStatements() (localctx INodesStatementsContext) {
	localctx = NewNodesStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ChainParserRULE_nodesStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(339)
		p.Match(ChainParserNODES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(340)
		p.Match(ChainParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserIDENTIFIER {
		{
			p.SetState(341)
			p.NodeStmt()
		}
		{
			p.SetState(342)
			p.Eos()
		}

		p.SetState(348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserEOS {
		{
			p.SetState(349)
			p.Match(ChainParserEOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeStmtContext is an interface to support dynamic dispatch.
type INodeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext

	// IsNodeStmtContext differentiates from other interfaces.
	IsNodeStmtContext()
}

type NodeStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeStmtContext() *NodeStmtContext {
	var p = new(NodeStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_nodeStmt
	return p
}

func InitEmptyNodeStmtContext(p *NodeStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_nodeStmt
}

func (*NodeStmtContext) IsNodeStmtContext() {}

func NewNodeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeStmtContext {
	var p = new(NodeStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_nodeStmt

	return p
}

func (s *NodeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeStmtContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *NodeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterNodeStmt(s)
	}
}

func (s *NodeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitNodeStmt(s)
	}
}

func (s *NodeStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitNodeStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) NodeStmt() (localctx INodeStmtContext) {
	localctx = NewNodeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ChainParserRULE_nodeStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectionStatementsContext is an interface to support dynamic dispatch.
type IDirectionStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SuccessStatements() ISuccessStatementsContext
	ErrorStatements() IErrorStatementsContext
	AbortStatements() IAbortStatementsContext
	BranchesStatements() IBranchesStatementsContext

	// IsDirectionStatementsContext differentiates from other interfaces.
	IsDirectionStatementsContext()
}

type DirectionStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectionStatementsContext() *DirectionStatementsContext {
	var p = new(DirectionStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_directionStatements
	return p
}

func InitEmptyDirectionStatementsContext(p *DirectionStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_directionStatements
}

func (*DirectionStatementsContext) IsDirectionStatementsContext() {}

func NewDirectionStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectionStatementsContext {
	var p = new(DirectionStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_directionStatements

	return p
}

func (s *DirectionStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectionStatementsContext) SuccessStatements() ISuccessStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuccessStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuccessStatementsContext)
}

func (s *DirectionStatementsContext) ErrorStatements() IErrorStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorStatementsContext)
}

func (s *DirectionStatementsContext) AbortStatements() IAbortStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbortStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbortStatementsContext)
}

func (s *DirectionStatementsContext) BranchesStatements() IBranchesStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchesStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchesStatementsContext)
}

func (s *DirectionStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectionStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectionStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterDirectionStatements(s)
	}
}

func (s *DirectionStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitDirectionStatements(s)
	}
}

func (s *DirectionStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitDirectionStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) DirectionStatements() (localctx IDirectionStatementsContext) {
	localctx = NewDirectionStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ChainParserRULE_directionStatements)
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserSUCCESS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(357)
			p.SuccessStatements()
		}

	case ChainParserERROR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(358)
			p.ErrorStatements()
		}

	case ChainParserABORT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(359)
			p.AbortStatements()
		}

	case ChainParserBRANCHES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(360)
			p.BranchesStatements()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuccessStatementsContext is an interface to support dynamic dispatch.
type ISuccessStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUCCESS() antlr.TerminalNode
	COLON() antlr.TerminalNode
	AllDirectionStmt() []IDirectionStmtContext
	DirectionStmt(i int) IDirectionStmtContext
	AllChain_eos() []IChain_eosContext
	Chain_eos(i int) IChain_eosContext

	// IsSuccessStatementsContext differentiates from other interfaces.
	IsSuccessStatementsContext()
}

type SuccessStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuccessStatementsContext() *SuccessStatementsContext {
	var p = new(SuccessStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_successStatements
	return p
}

func InitEmptySuccessStatementsContext(p *SuccessStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_successStatements
}

func (*SuccessStatementsContext) IsSuccessStatementsContext() {}

func NewSuccessStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuccessStatementsContext {
	var p = new(SuccessStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_successStatements

	return p
}

func (s *SuccessStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SuccessStatementsContext) SUCCESS() antlr.TerminalNode {
	return s.GetToken(ChainParserSUCCESS, 0)
}

func (s *SuccessStatementsContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *SuccessStatementsContext) AllDirectionStmt() []IDirectionStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectionStmtContext); ok {
			len++
		}
	}

	tst := make([]IDirectionStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectionStmtContext); ok {
			tst[i] = t.(IDirectionStmtContext)
			i++
		}
	}

	return tst
}

func (s *SuccessStatementsContext) DirectionStmt(i int) IDirectionStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionStmtContext)
}

func (s *SuccessStatementsContext) AllChain_eos() []IChain_eosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChain_eosContext); ok {
			len++
		}
	}

	tst := make([]IChain_eosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChain_eosContext); ok {
			tst[i] = t.(IChain_eosContext)
			i++
		}
	}

	return tst
}

func (s *SuccessStatementsContext) Chain_eos(i int) IChain_eosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChain_eosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChain_eosContext)
}

func (s *SuccessStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuccessStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuccessStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterSuccessStatements(s)
	}
}

func (s *SuccessStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitSuccessStatements(s)
	}
}

func (s *SuccessStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitSuccessStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) SuccessStatements() (localctx ISuccessStatementsContext) {
	localctx = NewSuccessStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ChainParserRULE_successStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.Match(ChainParserSUCCESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(364)
		p.Match(ChainParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ChainParserEND || _la == ChainParserIDENTIFIER {
		{
			p.SetState(365)
			p.DirectionStmt()
		}
		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ChainParserEOS {
			{
				p.SetState(366)
				p.Chain_eos()
			}

		}

		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorStatementsContext is an interface to support dynamic dispatch.
type IErrorStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR() antlr.TerminalNode
	COLON() antlr.TerminalNode
	AllDirectionStmt() []IDirectionStmtContext
	DirectionStmt(i int) IDirectionStmtContext
	AllChain_eos() []IChain_eosContext
	Chain_eos(i int) IChain_eosContext

	// IsErrorStatementsContext differentiates from other interfaces.
	IsErrorStatementsContext()
}

type ErrorStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorStatementsContext() *ErrorStatementsContext {
	var p = new(ErrorStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_errorStatements
	return p
}

func InitEmptyErrorStatementsContext(p *ErrorStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_errorStatements
}

func (*ErrorStatementsContext) IsErrorStatementsContext() {}

func NewErrorStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorStatementsContext {
	var p = new(ErrorStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_errorStatements

	return p
}

func (s *ErrorStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorStatementsContext) ERROR() antlr.TerminalNode {
	return s.GetToken(ChainParserERROR, 0)
}

func (s *ErrorStatementsContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *ErrorStatementsContext) AllDirectionStmt() []IDirectionStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectionStmtContext); ok {
			len++
		}
	}

	tst := make([]IDirectionStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectionStmtContext); ok {
			tst[i] = t.(IDirectionStmtContext)
			i++
		}
	}

	return tst
}

func (s *ErrorStatementsContext) DirectionStmt(i int) IDirectionStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionStmtContext)
}

func (s *ErrorStatementsContext) AllChain_eos() []IChain_eosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChain_eosContext); ok {
			len++
		}
	}

	tst := make([]IChain_eosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChain_eosContext); ok {
			tst[i] = t.(IChain_eosContext)
			i++
		}
	}

	return tst
}

func (s *ErrorStatementsContext) Chain_eos(i int) IChain_eosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChain_eosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChain_eosContext)
}

func (s *ErrorStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterErrorStatements(s)
	}
}

func (s *ErrorStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitErrorStatements(s)
	}
}

func (s *ErrorStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitErrorStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ErrorStatements() (localctx IErrorStatementsContext) {
	localctx = NewErrorStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ChainParserRULE_errorStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(373)
		p.Match(ChainParserERROR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(374)
		p.Match(ChainParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ChainParserEND || _la == ChainParserIDENTIFIER {
		{
			p.SetState(375)
			p.DirectionStmt()
		}
		p.SetState(377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ChainParserEOS {
			{
				p.SetState(376)
				p.Chain_eos()
			}

		}

		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbortStatementsContext is an interface to support dynamic dispatch.
type IAbortStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABORT() antlr.TerminalNode
	COLON() antlr.TerminalNode
	AllDirectionStmt() []IDirectionStmtContext
	DirectionStmt(i int) IDirectionStmtContext
	AllChain_eos() []IChain_eosContext
	Chain_eos(i int) IChain_eosContext

	// IsAbortStatementsContext differentiates from other interfaces.
	IsAbortStatementsContext()
}

type AbortStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbortStatementsContext() *AbortStatementsContext {
	var p = new(AbortStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_abortStatements
	return p
}

func InitEmptyAbortStatementsContext(p *AbortStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_abortStatements
}

func (*AbortStatementsContext) IsAbortStatementsContext() {}

func NewAbortStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbortStatementsContext {
	var p = new(AbortStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_abortStatements

	return p
}

func (s *AbortStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *AbortStatementsContext) ABORT() antlr.TerminalNode {
	return s.GetToken(ChainParserABORT, 0)
}

func (s *AbortStatementsContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *AbortStatementsContext) AllDirectionStmt() []IDirectionStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectionStmtContext); ok {
			len++
		}
	}

	tst := make([]IDirectionStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectionStmtContext); ok {
			tst[i] = t.(IDirectionStmtContext)
			i++
		}
	}

	return tst
}

func (s *AbortStatementsContext) DirectionStmt(i int) IDirectionStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionStmtContext)
}

func (s *AbortStatementsContext) AllChain_eos() []IChain_eosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChain_eosContext); ok {
			len++
		}
	}

	tst := make([]IChain_eosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChain_eosContext); ok {
			tst[i] = t.(IChain_eosContext)
			i++
		}
	}

	return tst
}

func (s *AbortStatementsContext) Chain_eos(i int) IChain_eosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChain_eosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChain_eosContext)
}

func (s *AbortStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbortStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbortStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterAbortStatements(s)
	}
}

func (s *AbortStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitAbortStatements(s)
	}
}

func (s *AbortStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitAbortStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) AbortStatements() (localctx IAbortStatementsContext) {
	localctx = NewAbortStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ChainParserRULE_abortStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(383)
		p.Match(ChainParserABORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(384)
		p.Match(ChainParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ChainParserEND || _la == ChainParserIDENTIFIER {
		{
			p.SetState(385)
			p.DirectionStmt()
		}
		p.SetState(387)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ChainParserEOS {
			{
				p.SetState(386)
				p.Chain_eos()
			}

		}

		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchesStatementsContext is an interface to support dynamic dispatch.
type IBranchesStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BRANCHES() antlr.TerminalNode
	COLON() antlr.TerminalNode
	AllBranchStmt() []IBranchStmtContext
	BranchStmt(i int) IBranchStmtContext
	AllChain_eos() []IChain_eosContext
	Chain_eos(i int) IChain_eosContext

	// IsBranchesStatementsContext differentiates from other interfaces.
	IsBranchesStatementsContext()
}

type BranchesStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranchesStatementsContext() *BranchesStatementsContext {
	var p = new(BranchesStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_branchesStatements
	return p
}

func InitEmptyBranchesStatementsContext(p *BranchesStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_branchesStatements
}

func (*BranchesStatementsContext) IsBranchesStatementsContext() {}

func NewBranchesStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchesStatementsContext {
	var p = new(BranchesStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_branchesStatements

	return p
}

func (s *BranchesStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchesStatementsContext) BRANCHES() antlr.TerminalNode {
	return s.GetToken(ChainParserBRANCHES, 0)
}

func (s *BranchesStatementsContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *BranchesStatementsContext) AllBranchStmt() []IBranchStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBranchStmtContext); ok {
			len++
		}
	}

	tst := make([]IBranchStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBranchStmtContext); ok {
			tst[i] = t.(IBranchStmtContext)
			i++
		}
	}

	return tst
}

func (s *BranchesStatementsContext) BranchStmt(i int) IBranchStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchStmtContext)
}

func (s *BranchesStatementsContext) AllChain_eos() []IChain_eosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChain_eosContext); ok {
			len++
		}
	}

	tst := make([]IChain_eosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChain_eosContext); ok {
			tst[i] = t.(IChain_eosContext)
			i++
		}
	}

	return tst
}

func (s *BranchesStatementsContext) Chain_eos(i int) IChain_eosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChain_eosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChain_eosContext)
}

func (s *BranchesStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchesStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchesStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterBranchesStatements(s)
	}
}

func (s *BranchesStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitBranchesStatements(s)
	}
}

func (s *BranchesStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitBranchesStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) BranchesStatements() (localctx IBranchesStatementsContext) {
	localctx = NewBranchesStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ChainParserRULE_branchesStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(393)
		p.Match(ChainParserBRANCHES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(394)
		p.Match(ChainParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ChainParserIDENTIFIER {
		{
			p.SetState(395)
			p.BranchStmt()
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ChainParserEOS {
			{
				p.SetState(396)
				p.Chain_eos()
			}

		}

		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectionStmtContext is an interface to support dynamic dispatch.
type IDirectionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDirection returns the direction token.
	GetDirection() antlr.Token

	// SetDirection sets the direction token.
	SetDirection(antlr.Token)

	// Getter signatures
	AllNodeName() []INodeNameContext
	NodeName(i int) INodeNameContext
	AllL_TO_R() []antlr.TerminalNode
	L_TO_R(i int) antlr.TerminalNode
	AllR_TO_L() []antlr.TerminalNode
	R_TO_L(i int) antlr.TerminalNode

	// IsDirectionStmtContext differentiates from other interfaces.
	IsDirectionStmtContext()
}

type DirectionStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	direction antlr.Token
}

func NewEmptyDirectionStmtContext() *DirectionStmtContext {
	var p = new(DirectionStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_directionStmt
	return p
}

func InitEmptyDirectionStmtContext(p *DirectionStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_directionStmt
}

func (*DirectionStmtContext) IsDirectionStmtContext() {}

func NewDirectionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectionStmtContext {
	var p = new(DirectionStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_directionStmt

	return p
}

func (s *DirectionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectionStmtContext) GetDirection() antlr.Token { return s.direction }

func (s *DirectionStmtContext) SetDirection(v antlr.Token) { s.direction = v }

func (s *DirectionStmtContext) AllNodeName() []INodeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INodeNameContext); ok {
			len++
		}
	}

	tst := make([]INodeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INodeNameContext); ok {
			tst[i] = t.(INodeNameContext)
			i++
		}
	}

	return tst
}

func (s *DirectionStmtContext) NodeName(i int) INodeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeNameContext)
}

func (s *DirectionStmtContext) AllL_TO_R() []antlr.TerminalNode {
	return s.GetTokens(ChainParserL_TO_R)
}

func (s *DirectionStmtContext) L_TO_R(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserL_TO_R, i)
}

func (s *DirectionStmtContext) AllR_TO_L() []antlr.TerminalNode {
	return s.GetTokens(ChainParserR_TO_L)
}

func (s *DirectionStmtContext) R_TO_L(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserR_TO_L, i)
}

func (s *DirectionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterDirectionStmt(s)
	}
}

func (s *DirectionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitDirectionStmt(s)
	}
}

func (s *DirectionStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitDirectionStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) DirectionStmt() (localctx IDirectionStmtContext) {
	localctx = NewDirectionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ChainParserRULE_directionStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(403)
		p.NodeName()
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserL_TO_R || _la == ChainParserR_TO_L {
		{
			p.SetState(404)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DirectionStmtContext).direction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ChainParserL_TO_R || _la == ChainParserR_TO_L) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DirectionStmtContext).direction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(405)
			p.NodeName()
		}

		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeNameContext is an interface to support dynamic dispatch.
type INodeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	END() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsNodeNameContext differentiates from other interfaces.
	IsNodeNameContext()
}

type NodeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeNameContext() *NodeNameContext {
	var p = new(NodeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_nodeName
	return p
}

func InitEmptyNodeNameContext(p *NodeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_nodeName
}

func (*NodeNameContext) IsNodeNameContext() {}

func NewNodeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeNameContext {
	var p = new(NodeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_nodeName

	return p
}

func (s *NodeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeNameContext) END() antlr.TerminalNode {
	return s.GetToken(ChainParserEND, 0)
}

func (s *NodeNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *NodeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterNodeName(s)
	}
}

func (s *NodeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitNodeName(s)
	}
}

func (s *NodeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitNodeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) NodeName() (localctx INodeNameContext) {
	localctx = NewNodeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ChainParserRULE_nodeName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(411)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ChainParserEND || _la == ChainParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchStmtContext is an interface to support dynamic dispatch.
type IBranchStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	BranchDirection() IBranchDirectionContext
	NodeName() INodeNameContext

	// IsBranchStmtContext differentiates from other interfaces.
	IsBranchStmtContext()
}

type BranchStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranchStmtContext() *BranchStmtContext {
	var p = new(BranchStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_branchStmt
	return p
}

func InitEmptyBranchStmtContext(p *BranchStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_branchStmt
}

func (*BranchStmtContext) IsBranchStmtContext() {}

func NewBranchStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchStmtContext {
	var p = new(BranchStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_branchStmt

	return p
}

func (s *BranchStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchStmtContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *BranchStmtContext) BranchDirection() IBranchDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchDirectionContext)
}

func (s *BranchStmtContext) NodeName() INodeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeNameContext)
}

func (s *BranchStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterBranchStmt(s)
	}
}

func (s *BranchStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitBranchStmt(s)
	}
}

func (s *BranchStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitBranchStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) BranchStmt() (localctx IBranchStmtContext) {
	localctx = NewBranchStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ChainParserRULE_branchStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(414)
		p.BranchDirection()
	}
	{
		p.SetState(415)
		p.NodeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchDirectionContext is an interface to support dynamic dispatch.
type IBranchDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	String_() IString_Context
	GREATER() antlr.TerminalNode

	// IsBranchDirectionContext differentiates from other interfaces.
	IsBranchDirectionContext()
}

type BranchDirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranchDirectionContext() *BranchDirectionContext {
	var p = new(BranchDirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_branchDirection
	return p
}

func InitEmptyBranchDirectionContext(p *BranchDirectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_branchDirection
}

func (*BranchDirectionContext) IsBranchDirectionContext() {}

func NewBranchDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchDirectionContext {
	var p = new(BranchDirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_branchDirection

	return p
}

func (s *BranchDirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchDirectionContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(ChainParserMINUS)
}

func (s *BranchDirectionContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserMINUS, i)
}

func (s *BranchDirectionContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *BranchDirectionContext) GREATER() antlr.TerminalNode {
	return s.GetToken(ChainParserGREATER, 0)
}

func (s *BranchDirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchDirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchDirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterBranchDirection(s)
	}
}

func (s *BranchDirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitBranchDirection(s)
	}
}

func (s *BranchDirectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitBranchDirection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) BranchDirection() (localctx IBranchDirectionContext) {
	localctx = NewBranchDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ChainParserRULE_branchDirection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(417)
		p.Match(ChainParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(418)
		p.String_()
	}
	{
		p.SetState(419)
		p.Match(ChainParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(420)
		p.Match(ChainParserGREATER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChain_eosContext is an interface to support dynamic dispatch.
type IChain_eosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOS() antlr.TerminalNode

	// IsChain_eosContext differentiates from other interfaces.
	IsChain_eosContext()
}

type Chain_eosContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChain_eosContext() *Chain_eosContext {
	var p = new(Chain_eosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_chain_eos
	return p
}

func InitEmptyChain_eosContext(p *Chain_eosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_chain_eos
}

func (*Chain_eosContext) IsChain_eosContext() {}

func NewChain_eosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Chain_eosContext {
	var p = new(Chain_eosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_chain_eos

	return p
}

func (s *Chain_eosContext) GetParser() antlr.Parser { return s.parser }

func (s *Chain_eosContext) EOS() antlr.TerminalNode {
	return s.GetToken(ChainParserEOS, 0)
}

func (s *Chain_eosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Chain_eosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Chain_eosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterChain_eos(s)
	}
}

func (s *Chain_eosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitChain_eos(s)
	}
}

func (s *Chain_eosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitChain_eos(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Chain_eos() (localctx IChain_eosContext) {
	localctx = NewChain_eosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ChainParserRULE_chain_eos)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.Match(ChainParserEOS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageClauseContext is an interface to support dynamic dispatch.
type IPackageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKAGE() antlr.TerminalNode
	PackageName() IPackageNameContext

	// IsPackageClauseContext differentiates from other interfaces.
	IsPackageClauseContext()
}

type PackageClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageClauseContext() *PackageClauseContext {
	var p = new(PackageClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_packageClause
	return p
}

func InitEmptyPackageClauseContext(p *PackageClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_packageClause
}

func (*PackageClauseContext) IsPackageClauseContext() {}

func NewPackageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageClauseContext {
	var p = new(PackageClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_packageClause

	return p
}

func (s *PackageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageClauseContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(ChainParserPACKAGE, 0)
}

func (s *PackageClauseContext) PackageName() IPackageNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *PackageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterPackageClause(s)
	}
}

func (s *PackageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitPackageClause(s)
	}
}

func (s *PackageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitPackageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) PackageClause() (localctx IPackageClauseContext) {
	localctx = NewPackageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ChainParserRULE_packageClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Match(ChainParserPACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(425)
		p.PackageName()
	}
	p.myreset()

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageNameContext is an interface to support dynamic dispatch.
type IPackageNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsPackageNameContext differentiates from other interfaces.
	IsPackageNameContext()
}

type PackageNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageNameContext() *PackageNameContext {
	var p = new(PackageNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_packageName
	return p
}

func InitEmptyPackageNameContext(p *PackageNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_packageName
}

func (*PackageNameContext) IsPackageNameContext() {}

func NewPackageNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageNameContext {
	var p = new(PackageNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_packageName

	return p
}

func (s *PackageNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterPackageName(s)
	}
}

func (s *PackageNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitPackageName(s)
	}
}

func (s *PackageNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitPackageName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) PackageName() (localctx IPackageNameContext) {
	localctx = NewPackageNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ChainParserRULE_packageName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(428)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ChainParserRULE_identifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(430)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclContext is an interface to support dynamic dispatch.
type IImportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	AllImportSpec() []IImportSpecContext
	ImportSpec(i int) IImportSpecContext
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsImportDeclContext differentiates from other interfaces.
	IsImportDeclContext()
}

type ImportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclContext() *ImportDeclContext {
	var p = new(ImportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_importDecl
	return p
}

func InitEmptyImportDeclContext(p *ImportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_importDecl
}

func (*ImportDeclContext) IsImportDeclContext() {}

func NewImportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclContext {
	var p = new(ImportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_importDecl

	return p
}

func (s *ImportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(ChainParserIMPORT, 0)
}

func (s *ImportDeclContext) AllImportSpec() []IImportSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportSpecContext); ok {
			len++
		}
	}

	tst := make([]IImportSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportSpecContext); ok {
			tst[i] = t.(IImportSpecContext)
			i++
		}
	}

	return tst
}

func (s *ImportDeclContext) ImportSpec(i int) IImportSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportSpecContext)
}

func (s *ImportDeclContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *ImportDeclContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *ImportDeclContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ImportDeclContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ImportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterImportDecl(s)
	}
}

func (s *ImportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitImportDecl(s)
	}
}

func (s *ImportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitImportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ImportDecl() (localctx IImportDeclContext) {
	localctx = NewImportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ChainParserRULE_importDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(432)
		p.Match(ChainParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserIDENTIFIER, ChainParserDOT, ChainParserRAW_STRING_LIT, ChainParserINTERPRETED_STRING_LIT:
		{
			p.SetState(433)
			p.ImportSpec()
		}

	case ChainParserL_PAREN:
		{
			p.SetState(434)
			p.Match(ChainParserL_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-36)) & ^0x3f) == 0 && ((int64(1)<<(_la-36))&54043195528448001) != 0 {
			{
				p.SetState(435)
				p.ImportSpec()
			}
			{
				p.SetState(436)
				p.Eos()
			}

			p.SetState(442)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(443)
			p.Match(ChainParserR_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportSpecContext is an interface to support dynamic dispatch.
type IImportSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportPath() IImportPathContext
	DOT() antlr.TerminalNode
	PackageName() IPackageNameContext

	// IsImportSpecContext differentiates from other interfaces.
	IsImportSpecContext()
}

type ImportSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportSpecContext() *ImportSpecContext {
	var p = new(ImportSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_importSpec
	return p
}

func InitEmptyImportSpecContext(p *ImportSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_importSpec
}

func (*ImportSpecContext) IsImportSpecContext() {}

func NewImportSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportSpecContext {
	var p = new(ImportSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_importSpec

	return p
}

func (s *ImportSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportSpecContext) ImportPath() IImportPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPathContext)
}

func (s *ImportSpecContext) DOT() antlr.TerminalNode {
	return s.GetToken(ChainParserDOT, 0)
}

func (s *ImportSpecContext) PackageName() IPackageNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *ImportSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterImportSpec(s)
	}
}

func (s *ImportSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitImportSpec(s)
	}
}

func (s *ImportSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitImportSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ImportSpec() (localctx IImportSpecContext) {
	localctx = NewImportSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ChainParserRULE_importSpec)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case ChainParserDOT:
		{
			p.SetState(446)
			p.Match(ChainParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ChainParserIDENTIFIER:
		{
			p.SetState(447)
			p.PackageName()
		}

	case ChainParserRAW_STRING_LIT, ChainParserINTERPRETED_STRING_LIT:

	default:
	}
	{
		p.SetState(450)
		p.ImportPath()
	}
	p.addImportSpec()

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPathContext is an interface to support dynamic dispatch.
type IImportPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	String_() IString_Context

	// IsImportPathContext differentiates from other interfaces.
	IsImportPathContext()
}

type ImportPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPathContext() *ImportPathContext {
	var p = new(ImportPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_importPath
	return p
}

func InitEmptyImportPathContext(p *ImportPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_importPath
}

func (*ImportPathContext) IsImportPathContext() {}

func NewImportPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPathContext {
	var p = new(ImportPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_importPath

	return p
}

func (s *ImportPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPathContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *ImportPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterImportPath(s)
	}
}

func (s *ImportPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitImportPath(s)
	}
}

func (s *ImportPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitImportPath(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ImportPath() (localctx IImportPathContext) {
	localctx = NewImportPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ChainParserRULE_importPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstDecl() IConstDeclContext
	TypeDecl() ITypeDeclContext
	VarDecl() IVarDeclContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ConstDecl() IConstDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstDeclContext)
}

func (s *DeclarationContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *DeclarationContext) VarDecl() IVarDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarDeclContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ChainParserRULE_declaration)
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserCONST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(455)
			p.ConstDecl()
		}

	case ChainParserTYPE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(456)
			p.TypeDecl()
		}

	case ChainParserVAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(457)
			p.VarDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstDeclContext is an interface to support dynamic dispatch.
type IConstDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	AllConstSpec() []IConstSpecContext
	ConstSpec(i int) IConstSpecContext
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsConstDeclContext differentiates from other interfaces.
	IsConstDeclContext()
}

type ConstDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstDeclContext() *ConstDeclContext {
	var p = new(ConstDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_constDecl
	return p
}

func InitEmptyConstDeclContext(p *ConstDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_constDecl
}

func (*ConstDeclContext) IsConstDeclContext() {}

func NewConstDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclContext {
	var p = new(ConstDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_constDecl

	return p
}

func (s *ConstDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclContext) CONST() antlr.TerminalNode {
	return s.GetToken(ChainParserCONST, 0)
}

func (s *ConstDeclContext) AllConstSpec() []IConstSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstSpecContext); ok {
			len++
		}
	}

	tst := make([]IConstSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstSpecContext); ok {
			tst[i] = t.(IConstSpecContext)
			i++
		}
	}

	return tst
}

func (s *ConstDeclContext) ConstSpec(i int) IConstSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstSpecContext)
}

func (s *ConstDeclContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *ConstDeclContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *ConstDeclContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ConstDeclContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ConstDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterConstDecl(s)
	}
}

func (s *ConstDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitConstDecl(s)
	}
}

func (s *ConstDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitConstDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ConstDecl() (localctx IConstDeclContext) {
	localctx = NewConstDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ChainParserRULE_constDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(460)
		p.Match(ChainParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserIDENTIFIER:
		{
			p.SetState(461)
			p.ConstSpec()
		}

	case ChainParserL_PAREN:
		{
			p.SetState(462)
			p.Match(ChainParserL_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ChainParserIDENTIFIER {
			{
				p.SetState(463)
				p.ConstSpec()
			}
			{
				p.SetState(464)
				p.Eos()
			}

			p.SetState(470)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(471)
			p.Match(ChainParserR_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstSpecContext is an interface to support dynamic dispatch.
type IConstSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	ASSIGN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	Type_() IType_Context

	// IsConstSpecContext differentiates from other interfaces.
	IsConstSpecContext()
}

type ConstSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstSpecContext() *ConstSpecContext {
	var p = new(ConstSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_constSpec
	return p
}

func InitEmptyConstSpecContext(p *ConstSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_constSpec
}

func (*ConstSpecContext) IsConstSpecContext() {}

func NewConstSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstSpecContext {
	var p = new(ConstSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_constSpec

	return p
}

func (s *ConstSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ConstSpecContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserASSIGN, 0)
}

func (s *ConstSpecContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ConstSpecContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ConstSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterConstSpec(s)
	}
}

func (s *ConstSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitConstSpec(s)
	}
}

func (s *ConstSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitConstSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ConstSpec() (localctx IConstSpecContext) {
	localctx = NewConstSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ChainParserRULE_constSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(474)
		p.IdentifierList()
	}
	p.SetState(480)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		p.SetState(476)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(475)
				p.Type_()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(478)
			p.Match(ChainParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(479)
			p.ExpressionList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ChainParserIDENTIFIER)
}

func (s *IdentifierListContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, i)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ChainParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ChainParserRULE_identifierList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(483)
				p.Match(ChainParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(484)
				p.Match(ChainParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ChainParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ChainParserRULE_expressionList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(490)
		p.expression(0)
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(491)
				p.Match(ChainParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(492)
				p.expression(0)
			}

		}
		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	AllTypeSpec() []ITypeSpecContext
	TypeSpec(i int) ITypeSpecContext
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsTypeDeclContext differentiates from other interfaces.
	IsTypeDeclContext()
}

type TypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclContext() *TypeDeclContext {
	var p = new(TypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeDecl
	return p
}

func InitEmptyTypeDeclContext(p *TypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeDecl
}

func (*TypeDeclContext) IsTypeDeclContext() {}

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext {
	var p = new(TypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeDecl

	return p
}

func (s *TypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ChainParserTYPE, 0)
}

func (s *TypeDeclContext) AllTypeSpec() []ITypeSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeSpecContext); ok {
			len++
		}
	}

	tst := make([]ITypeSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeSpecContext); ok {
			tst[i] = t.(ITypeSpecContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclContext) TypeSpec(i int) ITypeSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecContext)
}

func (s *TypeDeclContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *TypeDeclContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *TypeDeclContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeDecl(s)
	}
}

func (s *TypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeDecl(s)
	}
}

func (s *TypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeDecl() (localctx ITypeDeclContext) {
	localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ChainParserRULE_typeDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(ChainParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserIDENTIFIER:
		{
			p.SetState(499)
			p.TypeSpec()
		}

	case ChainParserL_PAREN:
		{
			p.SetState(500)
			p.Match(ChainParserL_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ChainParserIDENTIFIER {
			{
				p.SetState(501)
				p.TypeSpec()
			}
			{
				p.SetState(502)
				p.Eos()
			}

			p.SetState(508)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(509)
			p.Match(ChainParserR_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeSpecContext is an interface to support dynamic dispatch.
type ITypeSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AliasDecl() IAliasDeclContext
	TypeDef() ITypeDefContext

	// IsTypeSpecContext differentiates from other interfaces.
	IsTypeSpecContext()
}

type TypeSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecContext() *TypeSpecContext {
	var p = new(TypeSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeSpec
	return p
}

func InitEmptyTypeSpecContext(p *TypeSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeSpec
}

func (*TypeSpecContext) IsTypeSpecContext() {}

func NewTypeSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecContext {
	var p = new(TypeSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeSpec

	return p
}

func (s *TypeSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecContext) AliasDecl() IAliasDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasDeclContext)
}

func (s *TypeSpecContext) TypeDef() ITypeDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefContext)
}

func (s *TypeSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeSpec(s)
	}
}

func (s *TypeSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeSpec(s)
	}
}

func (s *TypeSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeSpec() (localctx ITypeSpecContext) {
	localctx = NewTypeSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ChainParserRULE_typeSpec)
	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(512)
			p.AliasDecl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(513)
			p.TypeDef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasDeclContext is an interface to support dynamic dispatch.
type IAliasDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Type_() IType_Context
	TypeParameters() ITypeParametersContext

	// IsAliasDeclContext differentiates from other interfaces.
	IsAliasDeclContext()
}

type AliasDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasDeclContext() *AliasDeclContext {
	var p = new(AliasDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_aliasDecl
	return p
}

func InitEmptyAliasDeclContext(p *AliasDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_aliasDecl
}

func (*AliasDeclContext) IsAliasDeclContext() {}

func NewAliasDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasDeclContext {
	var p = new(AliasDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_aliasDecl

	return p
}

func (s *AliasDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *AliasDeclContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserASSIGN, 0)
}

func (s *AliasDeclContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *AliasDeclContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *AliasDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterAliasDecl(s)
	}
}

func (s *AliasDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitAliasDecl(s)
	}
}

func (s *AliasDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitAliasDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) AliasDecl() (localctx IAliasDeclContext) {
	localctx = NewAliasDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ChainParserRULE_aliasDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(516)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ChainParserL_BRACKET {
		{
			p.SetState(517)
			p.TypeParameters()
		}

	}
	{
		p.SetState(520)
		p.Match(ChainParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(521)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefContext is an interface to support dynamic dispatch.
type ITypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Type_() IType_Context
	TypeParameters() ITypeParametersContext

	// IsTypeDefContext differentiates from other interfaces.
	IsTypeDefContext()
}

type TypeDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefContext() *TypeDefContext {
	var p = new(TypeDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeDef
	return p
}

func InitEmptyTypeDefContext(p *TypeDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeDef
}

func (*TypeDefContext) IsTypeDefContext() {}

func NewTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefContext {
	var p = new(TypeDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeDef

	return p
}

func (s *TypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *TypeDefContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeDefContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeDef(s)
	}
}

func (s *TypeDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeDef(s)
	}
}

func (s *TypeDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeDef() (localctx ITypeDefContext) {
	localctx = NewTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ChainParserRULE_typeDef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(525)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(524)
			p.TypeParameters()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(527)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	AllTypeParameterDecl() []ITypeParameterDeclContext
	TypeParameterDecl(i int) ITypeParameterDeclContext
	R_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeParameters
	return p
}

func InitEmptyTypeParametersContext(p *TypeParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeParameters
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserL_BRACKET, 0)
}

func (s *TypeParametersContext) AllTypeParameterDecl() []ITypeParameterDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterDeclContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterDeclContext); ok {
			tst[i] = t.(ITypeParameterDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameterDecl(i int) ITypeParameterDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterDeclContext)
}

func (s *TypeParametersContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserR_BRACKET, 0)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ChainParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (s *TypeParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ChainParserRULE_typeParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.Match(ChainParserL_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(530)
		p.TypeParameterDecl()
	}
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserCOMMA {
		{
			p.SetState(531)
			p.Match(ChainParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(532)
			p.TypeParameterDecl()
		}

		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(538)
		p.Match(ChainParserR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterDeclContext is an interface to support dynamic dispatch.
type ITypeParameterDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	TypeElement() ITypeElementContext

	// IsTypeParameterDeclContext differentiates from other interfaces.
	IsTypeParameterDeclContext()
}

type TypeParameterDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterDeclContext() *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeParameterDecl
	return p
}

func InitEmptyTypeParameterDeclContext(p *TypeParameterDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeParameterDecl
}

func (*TypeParameterDeclContext) IsTypeParameterDeclContext() {}

func NewTypeParameterDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeParameterDecl

	return p
}

func (s *TypeParameterDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterDeclContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TypeParameterDeclContext) TypeElement() ITypeElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeElementContext)
}

func (s *TypeParameterDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeParameterDecl(s)
	}
}

func (s *TypeParameterDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeParameterDecl(s)
	}
}

func (s *TypeParameterDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeParameterDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeParameterDecl() (localctx ITypeParameterDeclContext) {
	localctx = NewTypeParameterDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ChainParserRULE_typeParameterDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(540)
		p.IdentifierList()
	}
	{
		p.SetState(541)
		p.TypeElement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeElementContext is an interface to support dynamic dispatch.
type ITypeElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeTerm() []ITypeTermContext
	TypeTerm(i int) ITypeTermContext
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode

	// IsTypeElementContext differentiates from other interfaces.
	IsTypeElementContext()
}

type TypeElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeElementContext() *TypeElementContext {
	var p = new(TypeElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeElement
	return p
}

func InitEmptyTypeElementContext(p *TypeElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeElement
}

func (*TypeElementContext) IsTypeElementContext() {}

func NewTypeElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeElementContext {
	var p = new(TypeElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeElement

	return p
}

func (s *TypeElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeElementContext) AllTypeTerm() []ITypeTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTermContext); ok {
			len++
		}
	}

	tst := make([]ITypeTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTermContext); ok {
			tst[i] = t.(ITypeTermContext)
			i++
		}
	}

	return tst
}

func (s *TypeElementContext) TypeTerm(i int) ITypeTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTermContext)
}

func (s *TypeElementContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(ChainParserOR)
}

func (s *TypeElementContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserOR, i)
}

func (s *TypeElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeElement(s)
	}
}

func (s *TypeElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeElement(s)
	}
}

func (s *TypeElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeElement() (localctx ITypeElementContext) {
	localctx = NewTypeElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ChainParserRULE_typeElement)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.TypeTerm()
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(544)
				p.Match(ChainParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(545)
				p.TypeTerm()
			}

		}
		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeTermContext is an interface to support dynamic dispatch.
type ITypeTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	UNDERLYING() antlr.TerminalNode

	// IsTypeTermContext differentiates from other interfaces.
	IsTypeTermContext()
}

type TypeTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTermContext() *TypeTermContext {
	var p = new(TypeTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeTerm
	return p
}

func InitEmptyTypeTermContext(p *TypeTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeTerm
}

func (*TypeTermContext) IsTypeTermContext() {}

func NewTypeTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTermContext {
	var p = new(TypeTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeTerm

	return p
}

func (s *TypeTermContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTermContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeTermContext) UNDERLYING() antlr.TerminalNode {
	return s.GetToken(ChainParserUNDERLYING, 0)
}

func (s *TypeTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeTerm(s)
	}
}

func (s *TypeTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeTerm(s)
	}
}

func (s *TypeTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeTerm() (localctx ITypeTermContext) {
	localctx = NewTypeTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ChainParserRULE_typeTerm)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(552)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(551)
			p.Match(ChainParserUNDERLYING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(554)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclContext is an interface to support dynamic dispatch.
type IFunctionDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	Signature() ISignatureContext
	TypeParameters() ITypeParametersContext
	Block() IBlockContext

	// IsFunctionDeclContext differentiates from other interfaces.
	IsFunctionDeclContext()
}

type FunctionDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclContext() *FunctionDeclContext {
	var p = new(FunctionDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_functionDecl
	return p
}

func InitEmptyFunctionDeclContext(p *FunctionDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_functionDecl
}

func (*FunctionDeclContext) IsFunctionDeclContext() {}

func NewFunctionDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclContext {
	var p = new(FunctionDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_functionDecl

	return p
}

func (s *FunctionDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ChainParserFUNC, 0)
}

func (s *FunctionDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *FunctionDeclContext) Signature() ISignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *FunctionDeclContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FunctionDeclContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitFunctionDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) FunctionDecl() (localctx IFunctionDeclContext) {
	localctx = NewFunctionDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ChainParserRULE_functionDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Match(ChainParserFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(557)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ChainParserL_BRACKET {
		{
			p.SetState(558)
			p.TypeParameters()
		}

	}
	{
		p.SetState(561)
		p.Signature()
	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ChainParserL_CURLY {
		{
			p.SetState(562)
			p.Block()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclContext is an interface to support dynamic dispatch.
type IMethodDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	Receiver() IReceiverContext
	IDENTIFIER() antlr.TerminalNode
	Signature() ISignatureContext
	Block() IBlockContext

	// IsMethodDeclContext differentiates from other interfaces.
	IsMethodDeclContext()
}

type MethodDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclContext() *MethodDeclContext {
	var p = new(MethodDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_methodDecl
	return p
}

func InitEmptyMethodDeclContext(p *MethodDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_methodDecl
}

func (*MethodDeclContext) IsMethodDeclContext() {}

func NewMethodDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclContext {
	var p = new(MethodDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_methodDecl

	return p
}

func (s *MethodDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ChainParserFUNC, 0)
}

func (s *MethodDeclContext) Receiver() IReceiverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverContext)
}

func (s *MethodDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *MethodDeclContext) Signature() ISignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *MethodDeclContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterMethodDecl(s)
	}
}

func (s *MethodDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitMethodDecl(s)
	}
}

func (s *MethodDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitMethodDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) MethodDecl() (localctx IMethodDeclContext) {
	localctx = NewMethodDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ChainParserRULE_methodDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.Match(ChainParserFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(566)
		p.Receiver()
	}
	{
		p.SetState(567)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(568)
		p.Signature()
	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ChainParserL_CURLY {
		{
			p.SetState(569)
			p.Block()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReceiverContext is an interface to support dynamic dispatch.
type IReceiverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parameters() IParametersContext

	// IsReceiverContext differentiates from other interfaces.
	IsReceiverContext()
}

type ReceiverContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverContext() *ReceiverContext {
	var p = new(ReceiverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_receiver
	return p
}

func InitEmptyReceiverContext(p *ReceiverContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_receiver
}

func (*ReceiverContext) IsReceiverContext() {}

func NewReceiverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverContext {
	var p = new(ReceiverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_receiver

	return p
}

func (s *ReceiverContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *ReceiverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterReceiver(s)
	}
}

func (s *ReceiverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitReceiver(s)
	}
}

func (s *ReceiverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitReceiver(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Receiver() (localctx IReceiverContext) {
	localctx = NewReceiverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ChainParserRULE_receiver)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Parameters()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarDeclContext is an interface to support dynamic dispatch.
type IVarDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	AllVarSpec() []IVarSpecContext
	VarSpec(i int) IVarSpecContext
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsVarDeclContext differentiates from other interfaces.
	IsVarDeclContext()
}

type VarDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarDeclContext() *VarDeclContext {
	var p = new(VarDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_varDecl
	return p
}

func InitEmptyVarDeclContext(p *VarDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_varDecl
}

func (*VarDeclContext) IsVarDeclContext() {}

func NewVarDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarDeclContext {
	var p = new(VarDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_varDecl

	return p
}

func (s *VarDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *VarDeclContext) VAR() antlr.TerminalNode {
	return s.GetToken(ChainParserVAR, 0)
}

func (s *VarDeclContext) AllVarSpec() []IVarSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVarSpecContext); ok {
			len++
		}
	}

	tst := make([]IVarSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVarSpecContext); ok {
			tst[i] = t.(IVarSpecContext)
			i++
		}
	}

	return tst
}

func (s *VarDeclContext) VarSpec(i int) IVarSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarSpecContext)
}

func (s *VarDeclContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *VarDeclContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *VarDeclContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *VarDeclContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *VarDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterVarDecl(s)
	}
}

func (s *VarDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitVarDecl(s)
	}
}

func (s *VarDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitVarDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) VarDecl() (localctx IVarDeclContext) {
	localctx = NewVarDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ChainParserRULE_varDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(ChainParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserIDENTIFIER:
		{
			p.SetState(575)
			p.VarSpec()
		}

	case ChainParserL_PAREN:
		{
			p.SetState(576)
			p.Match(ChainParserL_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ChainParserIDENTIFIER {
			{
				p.SetState(577)
				p.VarSpec()
			}
			{
				p.SetState(578)
				p.Eos()
			}

			p.SetState(584)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(585)
			p.Match(ChainParserR_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarSpecContext is an interface to support dynamic dispatch.
type IVarSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	Type_() IType_Context
	ASSIGN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsVarSpecContext differentiates from other interfaces.
	IsVarSpecContext()
}

type VarSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarSpecContext() *VarSpecContext {
	var p = new(VarSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_varSpec
	return p
}

func InitEmptyVarSpecContext(p *VarSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_varSpec
}

func (*VarSpecContext) IsVarSpecContext() {}

func NewVarSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarSpecContext {
	var p = new(VarSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_varSpec

	return p
}

func (s *VarSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *VarSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VarSpecContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *VarSpecContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserASSIGN, 0)
}

func (s *VarSpecContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *VarSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterVarSpec(s)
	}
}

func (s *VarSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitVarSpec(s)
	}
}

func (s *VarSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitVarSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) VarSpec() (localctx IVarSpecContext) {
	localctx = NewVarSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ChainParserRULE_varSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.IdentifierList()
	}
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(589)
			p.Type_()
		}
		p.SetState(592)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(590)
				p.Match(ChainParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(591)
				p.ExpressionList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(594)
			p.Match(ChainParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(595)
			p.ExpressionList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_CURLY() antlr.TerminalNode
	StatementList() IStatementListContext
	R_CURLY() antlr.TerminalNode

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserL_CURLY, 0)
}

func (s *BlockContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *BlockContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserR_CURLY, 0)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ChainParserRULE_block)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.Match(ChainParserL_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(599)
		p.StatementList()
	}
	{
		p.SetState(600)
		p.Match(ChainParserR_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllEos() []IEosContext
	Eos(i int) IEosContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllEOS() []antlr.TerminalNode
	EOS(i int) antlr.TerminalNode

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_statementList
	return p
}

func InitEmptyStatementListContext(p *StatementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_statementList
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StatementListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(ChainParserSEMI)
}

func (s *StatementListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserSEMI, i)
}

func (s *StatementListContext) AllEOS() []antlr.TerminalNode {
	return s.GetTokens(ChainParserEOS)
}

func (s *StatementListContext) EOS(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserEOS, i)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (s *StatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) StatementList() (localctx IStatementListContext) {
	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ChainParserRULE_statementList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(605)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(602)
					p.Match(ChainParserSEMI)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				{
					p.SetState(603)
					p.Match(ChainParserEOS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(607)
				p.Statement()
			}
			{
				p.SetState(608)
				p.Eos()
			}

		}
		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	LabeledStmt() ILabeledStmtContext
	SimpleStmt() ISimpleStmtContext
	GoStmt() IGoStmtContext
	ReturnStmt() IReturnStmtContext
	BreakStmt() IBreakStmtContext
	ContinueStmt() IContinueStmtContext
	GotoStmt() IGotoStmtContext
	FallthroughStmt() IFallthroughStmtContext
	Block() IBlockContext
	IfStmt() IIfStmtContext
	SwitchStmt() ISwitchStmtContext
	SelectStmt() ISelectStmtContext
	ForStmt() IForStmtContext
	DeferStmt() IDeferStmtContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *StatementContext) LabeledStmt() ILabeledStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledStmtContext)
}

func (s *StatementContext) SimpleStmt() ISimpleStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *StatementContext) GoStmt() IGoStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGoStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGoStmtContext)
}

func (s *StatementContext) ReturnStmt() IReturnStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStmtContext)
}

func (s *StatementContext) BreakStmt() IBreakStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStmtContext)
}

func (s *StatementContext) ContinueStmt() IContinueStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStmtContext)
}

func (s *StatementContext) GotoStmt() IGotoStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStmtContext)
}

func (s *StatementContext) FallthroughStmt() IFallthroughStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFallthroughStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFallthroughStmtContext)
}

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *StatementContext) SwitchStmt() ISwitchStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStmtContext)
}

func (s *StatementContext) SelectStmt() ISelectStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStmtContext)
}

func (s *StatementContext) ForStmt() IForStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStmtContext)
}

func (s *StatementContext) DeferStmt() IDeferStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStmtContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ChainParserRULE_statement)
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(615)
			p.Declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(616)
			p.LabeledStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(617)
			p.SimpleStmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(618)
			p.GoStmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(619)
			p.ReturnStmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(620)
			p.BreakStmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(621)
			p.ContinueStmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(622)
			p.GotoStmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(623)
			p.FallthroughStmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(624)
			p.Block()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(625)
			p.IfStmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(626)
			p.SwitchStmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(627)
			p.SelectStmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(628)
			p.ForStmt()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(629)
			p.DeferStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStmtContext is an interface to support dynamic dispatch.
type ISimpleStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SendStmt() ISendStmtContext
	IncDecStmt() IIncDecStmtContext
	Assignment() IAssignmentContext
	ExpressionStmt() IExpressionStmtContext
	ShortVarDecl() IShortVarDeclContext

	// IsSimpleStmtContext differentiates from other interfaces.
	IsSimpleStmtContext()
}

type SimpleStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStmtContext() *SimpleStmtContext {
	var p = new(SimpleStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_simpleStmt
	return p
}

func InitEmptySimpleStmtContext(p *SimpleStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_simpleStmt
}

func (*SimpleStmtContext) IsSimpleStmtContext() {}

func NewSimpleStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStmtContext {
	var p = new(SimpleStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_simpleStmt

	return p
}

func (s *SimpleStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStmtContext) SendStmt() ISendStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendStmtContext)
}

func (s *SimpleStmtContext) IncDecStmt() IIncDecStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncDecStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncDecStmtContext)
}

func (s *SimpleStmtContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *SimpleStmtContext) ExpressionStmt() IExpressionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStmtContext)
}

func (s *SimpleStmtContext) ShortVarDecl() IShortVarDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShortVarDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShortVarDeclContext)
}

func (s *SimpleStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterSimpleStmt(s)
	}
}

func (s *SimpleStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitSimpleStmt(s)
	}
}

func (s *SimpleStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitSimpleStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) SimpleStmt() (localctx ISimpleStmtContext) {
	localctx = NewSimpleStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ChainParserRULE_simpleStmt)
	p.SetState(637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(632)
			p.SendStmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(633)
			p.IncDecStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(634)
			p.Assignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(635)
			p.ExpressionStmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(636)
			p.ShortVarDecl()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStmtContext is an interface to support dynamic dispatch.
type IExpressionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsExpressionStmtContext differentiates from other interfaces.
	IsExpressionStmtContext()
}

type ExpressionStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStmtContext() *ExpressionStmtContext {
	var p = new(ExpressionStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_expressionStmt
	return p
}

func InitEmptyExpressionStmtContext(p *ExpressionStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_expressionStmt
}

func (*ExpressionStmtContext) IsExpressionStmtContext() {}

func NewExpressionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStmtContext {
	var p = new(ExpressionStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_expressionStmt

	return p
}

func (s *ExpressionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterExpressionStmt(s)
	}
}

func (s *ExpressionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitExpressionStmt(s)
	}
}

func (s *ExpressionStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitExpressionStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ExpressionStmt() (localctx IExpressionStmtContext) {
	localctx = NewExpressionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ChainParserRULE_expressionStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISendStmtContext is an interface to support dynamic dispatch.
type ISendStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetChannel returns the channel rule contexts.
	GetChannel() IExpressionContext

	// SetChannel sets the channel rule contexts.
	SetChannel(IExpressionContext)

	// Getter signatures
	RECEIVE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsSendStmtContext differentiates from other interfaces.
	IsSendStmtContext()
}

type SendStmtContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	channel IExpressionContext
}

func NewEmptySendStmtContext() *SendStmtContext {
	var p = new(SendStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_sendStmt
	return p
}

func InitEmptySendStmtContext(p *SendStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_sendStmt
}

func (*SendStmtContext) IsSendStmtContext() {}

func NewSendStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStmtContext {
	var p = new(SendStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_sendStmt

	return p
}

func (s *SendStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStmtContext) GetChannel() IExpressionContext { return s.channel }

func (s *SendStmtContext) SetChannel(v IExpressionContext) { s.channel = v }

func (s *SendStmtContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(ChainParserRECEIVE, 0)
}

func (s *SendStmtContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SendStmtContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SendStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterSendStmt(s)
	}
}

func (s *SendStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitSendStmt(s)
	}
}

func (s *SendStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitSendStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) SendStmt() (localctx ISendStmtContext) {
	localctx = NewSendStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ChainParserRULE_sendStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)

		var _x = p.expression(0)

		localctx.(*SendStmtContext).channel = _x
	}
	{
		p.SetState(642)
		p.Match(ChainParserRECEIVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(643)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIncDecStmtContext is an interface to support dynamic dispatch.
type IIncDecStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	PLUS_PLUS() antlr.TerminalNode
	MINUS_MINUS() antlr.TerminalNode

	// IsIncDecStmtContext differentiates from other interfaces.
	IsIncDecStmtContext()
}

type IncDecStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncDecStmtContext() *IncDecStmtContext {
	var p = new(IncDecStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_incDecStmt
	return p
}

func InitEmptyIncDecStmtContext(p *IncDecStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_incDecStmt
}

func (*IncDecStmtContext) IsIncDecStmtContext() {}

func NewIncDecStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncDecStmtContext {
	var p = new(IncDecStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_incDecStmt

	return p
}

func (s *IncDecStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IncDecStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IncDecStmtContext) PLUS_PLUS() antlr.TerminalNode {
	return s.GetToken(ChainParserPLUS_PLUS, 0)
}

func (s *IncDecStmtContext) MINUS_MINUS() antlr.TerminalNode {
	return s.GetToken(ChainParserMINUS_MINUS, 0)
}

func (s *IncDecStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncDecStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncDecStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterIncDecStmt(s)
	}
}

func (s *IncDecStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitIncDecStmt(s)
	}
}

func (s *IncDecStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitIncDecStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) IncDecStmt() (localctx IIncDecStmtContext) {
	localctx = NewIncDecStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ChainParserRULE_incDecStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.expression(0)
	}
	{
		p.SetState(646)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ChainParserPLUS_PLUS || _la == ChainParserMINUS_MINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionList() []IExpressionListContext
	ExpressionList(i int) IExpressionListContext
	Assign_op() IAssign_opContext

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) AllExpressionList() []IExpressionListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionListContext); ok {
			len++
		}
	}

	tst := make([]IExpressionListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionListContext); ok {
			tst[i] = t.(IExpressionListContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentContext) ExpressionList(i int) IExpressionListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *AssignmentContext) Assign_op() IAssign_opContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssign_opContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssign_opContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (s *AssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ChainParserRULE_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.ExpressionList()
	}
	{
		p.SetState(649)
		p.Assign_op()
	}
	{
		p.SetState(650)
		p.ExpressionList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssign_opContext is an interface to support dynamic dispatch.
type IAssign_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	OR() antlr.TerminalNode
	CARET() antlr.TerminalNode
	STAR() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	LSHIFT() antlr.TerminalNode
	RSHIFT() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode
	BIT_CLEAR() antlr.TerminalNode

	// IsAssign_opContext differentiates from other interfaces.
	IsAssign_opContext()
}

type Assign_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssign_opContext() *Assign_opContext {
	var p = new(Assign_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_assign_op
	return p
}

func InitEmptyAssign_opContext(p *Assign_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_assign_op
}

func (*Assign_opContext) IsAssign_opContext() {}

func NewAssign_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assign_opContext {
	var p = new(Assign_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_assign_op

	return p
}

func (s *Assign_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Assign_opContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserASSIGN, 0)
}

func (s *Assign_opContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ChainParserPLUS, 0)
}

func (s *Assign_opContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ChainParserMINUS, 0)
}

func (s *Assign_opContext) OR() antlr.TerminalNode {
	return s.GetToken(ChainParserOR, 0)
}

func (s *Assign_opContext) CARET() antlr.TerminalNode {
	return s.GetToken(ChainParserCARET, 0)
}

func (s *Assign_opContext) STAR() antlr.TerminalNode {
	return s.GetToken(ChainParserSTAR, 0)
}

func (s *Assign_opContext) DIV() antlr.TerminalNode {
	return s.GetToken(ChainParserDIV, 0)
}

func (s *Assign_opContext) MOD() antlr.TerminalNode {
	return s.GetToken(ChainParserMOD, 0)
}

func (s *Assign_opContext) LSHIFT() antlr.TerminalNode {
	return s.GetToken(ChainParserLSHIFT, 0)
}

func (s *Assign_opContext) RSHIFT() antlr.TerminalNode {
	return s.GetToken(ChainParserRSHIFT, 0)
}

func (s *Assign_opContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ChainParserAMPERSAND, 0)
}

func (s *Assign_opContext) BIT_CLEAR() antlr.TerminalNode {
	return s.GetToken(ChainParserBIT_CLEAR, 0)
}

func (s *Assign_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assign_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assign_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterAssign_op(s)
	}
}

func (s *Assign_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitAssign_op(s)
	}
}

func (s *Assign_opContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitAssign_op(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Assign_op() (localctx IAssign_opContext) {
	localctx = NewAssign_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ChainParserRULE_assign_op)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-60)) & ^0x3f) == 0 && ((int64(1)<<(_la-60))&7999) != 0 {
		{
			p.SetState(652)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-60)) & ^0x3f) == 0 && ((int64(1)<<(_la-60))&7999) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(655)
		p.Match(ChainParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShortVarDeclContext is an interface to support dynamic dispatch.
type IShortVarDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	DECLARE_ASSIGN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsShortVarDeclContext differentiates from other interfaces.
	IsShortVarDeclContext()
}

type ShortVarDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortVarDeclContext() *ShortVarDeclContext {
	var p = new(ShortVarDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_shortVarDecl
	return p
}

func InitEmptyShortVarDeclContext(p *ShortVarDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_shortVarDecl
}

func (*ShortVarDeclContext) IsShortVarDeclContext() {}

func NewShortVarDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortVarDeclContext {
	var p = new(ShortVarDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_shortVarDecl

	return p
}

func (s *ShortVarDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortVarDeclContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShortVarDeclContext) DECLARE_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserDECLARE_ASSIGN, 0)
}

func (s *ShortVarDeclContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ShortVarDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortVarDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortVarDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterShortVarDecl(s)
	}
}

func (s *ShortVarDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitShortVarDecl(s)
	}
}

func (s *ShortVarDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitShortVarDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ShortVarDecl() (localctx IShortVarDeclContext) {
	localctx = NewShortVarDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ChainParserRULE_shortVarDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.IdentifierList()
	}
	{
		p.SetState(658)
		p.Match(ChainParserDECLARE_ASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(659)
		p.ExpressionList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledStmtContext is an interface to support dynamic dispatch.
type ILabeledStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Statement() IStatementContext

	// IsLabeledStmtContext differentiates from other interfaces.
	IsLabeledStmtContext()
}

type LabeledStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStmtContext() *LabeledStmtContext {
	var p = new(LabeledStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_labeledStmt
	return p
}

func InitEmptyLabeledStmtContext(p *LabeledStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_labeledStmt
}

func (*LabeledStmtContext) IsLabeledStmtContext() {}

func NewLabeledStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStmtContext {
	var p = new(LabeledStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_labeledStmt

	return p
}

func (s *LabeledStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStmtContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *LabeledStmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *LabeledStmtContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterLabeledStmt(s)
	}
}

func (s *LabeledStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitLabeledStmt(s)
	}
}

func (s *LabeledStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitLabeledStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) LabeledStmt() (localctx ILabeledStmtContext) {
	localctx = NewLabeledStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ChainParserRULE_labeledStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(661)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(662)
		p.Match(ChainParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(663)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStmtContext is an interface to support dynamic dispatch.
type IReturnStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsReturnStmtContext differentiates from other interfaces.
	IsReturnStmtContext()
}

type ReturnStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStmtContext() *ReturnStmtContext {
	var p = new(ReturnStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_returnStmt
	return p
}

func InitEmptyReturnStmtContext(p *ReturnStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_returnStmt
}

func (*ReturnStmtContext) IsReturnStmtContext() {}

func NewReturnStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStmtContext {
	var p = new(ReturnStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_returnStmt

	return p
}

func (s *ReturnStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ChainParserRETURN, 0)
}

func (s *ReturnStmtContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ReturnStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterReturnStmt(s)
	}
}

func (s *ReturnStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitReturnStmt(s)
	}
}

func (s *ReturnStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitReturnStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ReturnStmt() (localctx IReturnStmtContext) {
	localctx = NewReturnStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ChainParserRULE_returnStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(ChainParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(667)
			p.ExpressionList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStmtContext is an interface to support dynamic dispatch.
type IBreakStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsBreakStmtContext differentiates from other interfaces.
	IsBreakStmtContext()
}

type BreakStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStmtContext() *BreakStmtContext {
	var p = new(BreakStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_breakStmt
	return p
}

func InitEmptyBreakStmtContext(p *BreakStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_breakStmt
}

func (*BreakStmtContext) IsBreakStmtContext() {}

func NewBreakStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStmtContext {
	var p = new(BreakStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_breakStmt

	return p
}

func (s *BreakStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ChainParserBREAK, 0)
}

func (s *BreakStmtContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *BreakStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterBreakStmt(s)
	}
}

func (s *BreakStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitBreakStmt(s)
	}
}

func (s *BreakStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitBreakStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) BreakStmt() (localctx IBreakStmtContext) {
	localctx = NewBreakStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ChainParserRULE_breakStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Match(ChainParserBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(671)
			p.Match(ChainParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStmtContext is an interface to support dynamic dispatch.
type IContinueStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsContinueStmtContext differentiates from other interfaces.
	IsContinueStmtContext()
}

type ContinueStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStmtContext() *ContinueStmtContext {
	var p = new(ContinueStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_continueStmt
	return p
}

func InitEmptyContinueStmtContext(p *ContinueStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_continueStmt
}

func (*ContinueStmtContext) IsContinueStmtContext() {}

func NewContinueStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStmtContext {
	var p = new(ContinueStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_continueStmt

	return p
}

func (s *ContinueStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ChainParserCONTINUE, 0)
}

func (s *ContinueStmtContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *ContinueStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterContinueStmt(s)
	}
}

func (s *ContinueStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitContinueStmt(s)
	}
}

func (s *ContinueStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitContinueStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ContinueStmt() (localctx IContinueStmtContext) {
	localctx = NewContinueStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ChainParserRULE_continueStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.Match(ChainParserCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(676)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(675)
			p.Match(ChainParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotoStmtContext is an interface to support dynamic dispatch.
type IGotoStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOTO() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsGotoStmtContext differentiates from other interfaces.
	IsGotoStmtContext()
}

type GotoStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStmtContext() *GotoStmtContext {
	var p = new(GotoStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_gotoStmt
	return p
}

func InitEmptyGotoStmtContext(p *GotoStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_gotoStmt
}

func (*GotoStmtContext) IsGotoStmtContext() {}

func NewGotoStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStmtContext {
	var p = new(GotoStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_gotoStmt

	return p
}

func (s *GotoStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStmtContext) GOTO() antlr.TerminalNode {
	return s.GetToken(ChainParserGOTO, 0)
}

func (s *GotoStmtContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *GotoStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterGotoStmt(s)
	}
}

func (s *GotoStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitGotoStmt(s)
	}
}

func (s *GotoStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitGotoStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) GotoStmt() (localctx IGotoStmtContext) {
	localctx = NewGotoStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ChainParserRULE_gotoStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(ChainParserGOTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(679)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFallthroughStmtContext is an interface to support dynamic dispatch.
type IFallthroughStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FALLTHROUGH() antlr.TerminalNode

	// IsFallthroughStmtContext differentiates from other interfaces.
	IsFallthroughStmtContext()
}

type FallthroughStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFallthroughStmtContext() *FallthroughStmtContext {
	var p = new(FallthroughStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_fallthroughStmt
	return p
}

func InitEmptyFallthroughStmtContext(p *FallthroughStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_fallthroughStmt
}

func (*FallthroughStmtContext) IsFallthroughStmtContext() {}

func NewFallthroughStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FallthroughStmtContext {
	var p = new(FallthroughStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_fallthroughStmt

	return p
}

func (s *FallthroughStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *FallthroughStmtContext) FALLTHROUGH() antlr.TerminalNode {
	return s.GetToken(ChainParserFALLTHROUGH, 0)
}

func (s *FallthroughStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FallthroughStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FallthroughStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterFallthroughStmt(s)
	}
}

func (s *FallthroughStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitFallthroughStmt(s)
	}
}

func (s *FallthroughStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitFallthroughStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) FallthroughStmt() (localctx IFallthroughStmtContext) {
	localctx = NewFallthroughStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ChainParserRULE_fallthroughStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.Match(ChainParserFALLTHROUGH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeferStmtContext is an interface to support dynamic dispatch.
type IDeferStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeferStmtContext differentiates from other interfaces.
	IsDeferStmtContext()
}

type DeferStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStmtContext() *DeferStmtContext {
	var p = new(DeferStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_deferStmt
	return p
}

func InitEmptyDeferStmtContext(p *DeferStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_deferStmt
}

func (*DeferStmtContext) IsDeferStmtContext() {}

func NewDeferStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStmtContext {
	var p = new(DeferStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_deferStmt

	return p
}

func (s *DeferStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStmtContext) DEFER() antlr.TerminalNode {
	return s.GetToken(ChainParserDEFER, 0)
}

func (s *DeferStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeferStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeferStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterDeferStmt(s)
	}
}

func (s *DeferStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitDeferStmt(s)
	}
}

func (s *DeferStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitDeferStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) DeferStmt() (localctx IDeferStmtContext) {
	localctx = NewDeferStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ChainParserRULE_deferStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Match(ChainParserDEFER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(684)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	Expression() IExpressionContext
	SimpleStmt() ISimpleStmtContext
	SEMI() antlr.TerminalNode
	EOS() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	IfStmt() IIfStmtContext

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ChainParserIF, 0)
}

func (s *IfStmtContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStmtContext) SimpleStmt() ISimpleStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *IfStmtContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ChainParserSEMI, 0)
}

func (s *IfStmtContext) EOS() antlr.TerminalNode {
	return s.GetToken(ChainParserEOS, 0)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ChainParserELSE, 0)
}

func (s *IfStmtContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (s *IfStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitIfStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ChainParserRULE_ifStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(ChainParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(694)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(687)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(688)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ChainParserSEMI || _la == ChainParserEOS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(689)
			p.expression(0)
		}

	case 3:
		{
			p.SetState(690)
			p.SimpleStmt()
		}
		{
			p.SetState(691)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ChainParserSEMI || _la == ChainParserEOS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(692)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(696)
		p.Block()
	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(697)
			p.Match(ChainParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ChainParserIF:
			{
				p.SetState(698)
				p.IfStmt()
			}

		case ChainParserL_CURLY:
			{
				p.SetState(699)
				p.Block()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchStmtContext is an interface to support dynamic dispatch.
type ISwitchStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprSwitchStmt() IExprSwitchStmtContext
	TypeSwitchStmt() ITypeSwitchStmtContext

	// IsSwitchStmtContext differentiates from other interfaces.
	IsSwitchStmtContext()
}

type SwitchStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStmtContext() *SwitchStmtContext {
	var p = new(SwitchStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_switchStmt
	return p
}

func InitEmptySwitchStmtContext(p *SwitchStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_switchStmt
}

func (*SwitchStmtContext) IsSwitchStmtContext() {}

func NewSwitchStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStmtContext {
	var p = new(SwitchStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_switchStmt

	return p
}

func (s *SwitchStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStmtContext) ExprSwitchStmt() IExprSwitchStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSwitchStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSwitchStmtContext)
}

func (s *SwitchStmtContext) TypeSwitchStmt() ITypeSwitchStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSwitchStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSwitchStmtContext)
}

func (s *SwitchStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterSwitchStmt(s)
	}
}

func (s *SwitchStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitSwitchStmt(s)
	}
}

func (s *SwitchStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitSwitchStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) SwitchStmt() (localctx ISwitchStmtContext) {
	localctx = NewSwitchStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ChainParserRULE_switchStmt)
	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(704)
			p.ExprSwitchStmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(705)
			p.TypeSwitchStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprSwitchStmtContext is an interface to support dynamic dispatch.
type IExprSwitchStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	Eos() IEosContext
	AllExprCaseClause() []IExprCaseClauseContext
	ExprCaseClause(i int) IExprCaseClauseContext
	Expression() IExpressionContext
	SimpleStmt() ISimpleStmtContext

	// IsExprSwitchStmtContext differentiates from other interfaces.
	IsExprSwitchStmtContext()
}

type ExprSwitchStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprSwitchStmtContext() *ExprSwitchStmtContext {
	var p = new(ExprSwitchStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_exprSwitchStmt
	return p
}

func InitEmptyExprSwitchStmtContext(p *ExprSwitchStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_exprSwitchStmt
}

func (*ExprSwitchStmtContext) IsExprSwitchStmtContext() {}

func NewExprSwitchStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprSwitchStmtContext {
	var p = new(ExprSwitchStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_exprSwitchStmt

	return p
}

func (s *ExprSwitchStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprSwitchStmtContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ChainParserSWITCH, 0)
}

func (s *ExprSwitchStmtContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserL_CURLY, 0)
}

func (s *ExprSwitchStmtContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserR_CURLY, 0)
}

func (s *ExprSwitchStmtContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExprSwitchStmtContext) AllExprCaseClause() []IExprCaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprCaseClauseContext); ok {
			len++
		}
	}

	tst := make([]IExprCaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprCaseClauseContext); ok {
			tst[i] = t.(IExprCaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *ExprSwitchStmtContext) ExprCaseClause(i int) IExprCaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprCaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprCaseClauseContext)
}

func (s *ExprSwitchStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExprSwitchStmtContext) SimpleStmt() ISimpleStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *ExprSwitchStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSwitchStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprSwitchStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterExprSwitchStmt(s)
	}
}

func (s *ExprSwitchStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitExprSwitchStmt(s)
	}
}

func (s *ExprSwitchStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitExprSwitchStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ExprSwitchStmt() (localctx IExprSwitchStmtContext) {
	localctx = NewExprSwitchStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ChainParserRULE_exprSwitchStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(ChainParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.SetState(710)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(709)
				p.expression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.SetState(713)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(712)
				p.SimpleStmt()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(715)
			p.Eos()
		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(716)
				p.expression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(721)
		p.Match(ChainParserL_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserCASE || _la == ChainParserDEFAULT {
		{
			p.SetState(722)
			p.ExprCaseClause()
		}

		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(728)
		p.Match(ChainParserR_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprCaseClauseContext is an interface to support dynamic dispatch.
type IExprCaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExprSwitchCase() IExprSwitchCaseContext
	COLON() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsExprCaseClauseContext differentiates from other interfaces.
	IsExprCaseClauseContext()
}

type ExprCaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprCaseClauseContext() *ExprCaseClauseContext {
	var p = new(ExprCaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_exprCaseClause
	return p
}

func InitEmptyExprCaseClauseContext(p *ExprCaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_exprCaseClause
}

func (*ExprCaseClauseContext) IsExprCaseClauseContext() {}

func NewExprCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprCaseClauseContext {
	var p = new(ExprCaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_exprCaseClause

	return p
}

func (s *ExprCaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprCaseClauseContext) ExprSwitchCase() IExprSwitchCaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprSwitchCaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprSwitchCaseContext)
}

func (s *ExprCaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *ExprCaseClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *ExprCaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprCaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprCaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterExprCaseClause(s)
	}
}

func (s *ExprCaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitExprCaseClause(s)
	}
}

func (s *ExprCaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitExprCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ExprCaseClause() (localctx IExprCaseClauseContext) {
	localctx = NewExprCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ChainParserRULE_exprCaseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.ExprSwitchCase()
	}
	{
		p.SetState(731)
		p.Match(ChainParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(732)
		p.StatementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprSwitchCaseContext is an interface to support dynamic dispatch.
type IExprSwitchCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	DEFAULT() antlr.TerminalNode

	// IsExprSwitchCaseContext differentiates from other interfaces.
	IsExprSwitchCaseContext()
}

type ExprSwitchCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprSwitchCaseContext() *ExprSwitchCaseContext {
	var p = new(ExprSwitchCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_exprSwitchCase
	return p
}

func InitEmptyExprSwitchCaseContext(p *ExprSwitchCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_exprSwitchCase
}

func (*ExprSwitchCaseContext) IsExprSwitchCaseContext() {}

func NewExprSwitchCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprSwitchCaseContext {
	var p = new(ExprSwitchCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_exprSwitchCase

	return p
}

func (s *ExprSwitchCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprSwitchCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(ChainParserCASE, 0)
}

func (s *ExprSwitchCaseContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ExprSwitchCaseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ChainParserDEFAULT, 0)
}

func (s *ExprSwitchCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprSwitchCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprSwitchCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterExprSwitchCase(s)
	}
}

func (s *ExprSwitchCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitExprSwitchCase(s)
	}
}

func (s *ExprSwitchCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitExprSwitchCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ExprSwitchCase() (localctx IExprSwitchCaseContext) {
	localctx = NewExprSwitchCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ChainParserRULE_exprSwitchCase)
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(734)
			p.Match(ChainParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(735)
			p.ExpressionList()
		}

	case ChainParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(736)
			p.Match(ChainParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeSwitchStmtContext is an interface to support dynamic dispatch.
type ITypeSwitchStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	TypeSwitchGuard() ITypeSwitchGuardContext
	Eos() IEosContext
	SimpleStmt() ISimpleStmtContext
	AllTypeCaseClause() []ITypeCaseClauseContext
	TypeCaseClause(i int) ITypeCaseClauseContext

	// IsTypeSwitchStmtContext differentiates from other interfaces.
	IsTypeSwitchStmtContext()
}

type TypeSwitchStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSwitchStmtContext() *TypeSwitchStmtContext {
	var p = new(TypeSwitchStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeSwitchStmt
	return p
}

func InitEmptyTypeSwitchStmtContext(p *TypeSwitchStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeSwitchStmt
}

func (*TypeSwitchStmtContext) IsTypeSwitchStmtContext() {}

func NewTypeSwitchStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSwitchStmtContext {
	var p = new(TypeSwitchStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeSwitchStmt

	return p
}

func (s *TypeSwitchStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSwitchStmtContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ChainParserSWITCH, 0)
}

func (s *TypeSwitchStmtContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserL_CURLY, 0)
}

func (s *TypeSwitchStmtContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserR_CURLY, 0)
}

func (s *TypeSwitchStmtContext) TypeSwitchGuard() ITypeSwitchGuardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSwitchGuardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSwitchGuardContext)
}

func (s *TypeSwitchStmtContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *TypeSwitchStmtContext) SimpleStmt() ISimpleStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *TypeSwitchStmtContext) AllTypeCaseClause() []ITypeCaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeCaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ITypeCaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeCaseClauseContext); ok {
			tst[i] = t.(ITypeCaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *TypeSwitchStmtContext) TypeCaseClause(i int) ITypeCaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCaseClauseContext)
}

func (s *TypeSwitchStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSwitchStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSwitchStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeSwitchStmt(s)
	}
}

func (s *TypeSwitchStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeSwitchStmt(s)
	}
}

func (s *TypeSwitchStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeSwitchStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeSwitchStmt() (localctx ITypeSwitchStmtContext) {
	localctx = NewTypeSwitchStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ChainParserRULE_typeSwitchStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(ChainParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(740)
			p.TypeSwitchGuard()
		}

	case 2:
		{
			p.SetState(741)
			p.Eos()
		}
		{
			p.SetState(742)
			p.TypeSwitchGuard()
		}

	case 3:
		{
			p.SetState(744)
			p.SimpleStmt()
		}
		{
			p.SetState(745)
			p.Eos()
		}
		{
			p.SetState(746)
			p.TypeSwitchGuard()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(750)
		p.Match(ChainParserL_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserCASE || _la == ChainParserDEFAULT {
		{
			p.SetState(751)
			p.TypeCaseClause()
		}

		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(757)
		p.Match(ChainParserR_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeSwitchGuardContext is an interface to support dynamic dispatch.
type ITypeSwitchGuardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	DOT() antlr.TerminalNode
	L_PAREN() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	DECLARE_ASSIGN() antlr.TerminalNode

	// IsTypeSwitchGuardContext differentiates from other interfaces.
	IsTypeSwitchGuardContext()
}

type TypeSwitchGuardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSwitchGuardContext() *TypeSwitchGuardContext {
	var p = new(TypeSwitchGuardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeSwitchGuard
	return p
}

func InitEmptyTypeSwitchGuardContext(p *TypeSwitchGuardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeSwitchGuard
}

func (*TypeSwitchGuardContext) IsTypeSwitchGuardContext() {}

func NewTypeSwitchGuardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSwitchGuardContext {
	var p = new(TypeSwitchGuardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeSwitchGuard

	return p
}

func (s *TypeSwitchGuardContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSwitchGuardContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *TypeSwitchGuardContext) DOT() antlr.TerminalNode {
	return s.GetToken(ChainParserDOT, 0)
}

func (s *TypeSwitchGuardContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *TypeSwitchGuardContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ChainParserTYPE, 0)
}

func (s *TypeSwitchGuardContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *TypeSwitchGuardContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *TypeSwitchGuardContext) DECLARE_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserDECLARE_ASSIGN, 0)
}

func (s *TypeSwitchGuardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSwitchGuardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSwitchGuardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeSwitchGuard(s)
	}
}

func (s *TypeSwitchGuardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeSwitchGuard(s)
	}
}

func (s *TypeSwitchGuardContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeSwitchGuard(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeSwitchGuard() (localctx ITypeSwitchGuardContext) {
	localctx = NewTypeSwitchGuardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ChainParserRULE_typeSwitchGuard)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(761)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(759)
			p.Match(ChainParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(760)
			p.Match(ChainParserDECLARE_ASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(763)
		p.PrimaryExpr()
	}
	{
		p.SetState(764)
		p.Match(ChainParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(765)
		p.Match(ChainParserL_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(766)
		p.Match(ChainParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(767)
		p.Match(ChainParserR_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeCaseClauseContext is an interface to support dynamic dispatch.
type ITypeCaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSwitchCase() ITypeSwitchCaseContext
	COLON() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsTypeCaseClauseContext differentiates from other interfaces.
	IsTypeCaseClauseContext()
}

type TypeCaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeCaseClauseContext() *TypeCaseClauseContext {
	var p = new(TypeCaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeCaseClause
	return p
}

func InitEmptyTypeCaseClauseContext(p *TypeCaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeCaseClause
}

func (*TypeCaseClauseContext) IsTypeCaseClauseContext() {}

func NewTypeCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeCaseClauseContext {
	var p = new(TypeCaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeCaseClause

	return p
}

func (s *TypeCaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeCaseClauseContext) TypeSwitchCase() ITypeSwitchCaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSwitchCaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSwitchCaseContext)
}

func (s *TypeCaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *TypeCaseClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *TypeCaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeCaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeCaseClause(s)
	}
}

func (s *TypeCaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeCaseClause(s)
	}
}

func (s *TypeCaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeCaseClause() (localctx ITypeCaseClauseContext) {
	localctx = NewTypeCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ChainParserRULE_typeCaseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.TypeSwitchCase()
	}
	{
		p.SetState(770)
		p.Match(ChainParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(771)
		p.StatementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeSwitchCaseContext is an interface to support dynamic dispatch.
type ITypeSwitchCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	TypeList() ITypeListContext
	DEFAULT() antlr.TerminalNode

	// IsTypeSwitchCaseContext differentiates from other interfaces.
	IsTypeSwitchCaseContext()
}

type TypeSwitchCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSwitchCaseContext() *TypeSwitchCaseContext {
	var p = new(TypeSwitchCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeSwitchCase
	return p
}

func InitEmptyTypeSwitchCaseContext(p *TypeSwitchCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeSwitchCase
}

func (*TypeSwitchCaseContext) IsTypeSwitchCaseContext() {}

func NewTypeSwitchCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSwitchCaseContext {
	var p = new(TypeSwitchCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeSwitchCase

	return p
}

func (s *TypeSwitchCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSwitchCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(ChainParserCASE, 0)
}

func (s *TypeSwitchCaseContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeSwitchCaseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ChainParserDEFAULT, 0)
}

func (s *TypeSwitchCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSwitchCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSwitchCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeSwitchCase(s)
	}
}

func (s *TypeSwitchCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeSwitchCase(s)
	}
}

func (s *TypeSwitchCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeSwitchCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeSwitchCase() (localctx ITypeSwitchCaseContext) {
	localctx = NewTypeSwitchCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ChainParserRULE_typeSwitchCase)
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(773)
			p.Match(ChainParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(774)
			p.TypeList()
		}

	case ChainParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(775)
			p.Match(ChainParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []IType_Context
	Type_(i int) IType_Context
	AllNIL_LIT() []antlr.TerminalNode
	NIL_LIT(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllType_() []IType_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_Context); ok {
			len++
		}
	}

	tst := make([]IType_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_Context); ok {
			tst[i] = t.(IType_Context)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Type_(i int) IType_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeListContext) AllNIL_LIT() []antlr.TerminalNode {
	return s.GetTokens(ChainParserNIL_LIT)
}

func (s *TypeListContext) NIL_LIT(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserNIL_LIT, i)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ChainParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ChainParserRULE_typeList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(778)
			p.Type_()
		}

	case 2:
		{
			p.SetState(779)
			p.Match(ChainParserNIL_LIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(782)
				p.Match(ChainParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(785)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(783)
					p.Type_()
				}

			case 2:
				{
					p.SetState(784)
					p.Match(ChainParserNIL_LIT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStmtContext is an interface to support dynamic dispatch.
type ISelectStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	AllCommClause() []ICommClauseContext
	CommClause(i int) ICommClauseContext

	// IsSelectStmtContext differentiates from other interfaces.
	IsSelectStmtContext()
}

type SelectStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStmtContext() *SelectStmtContext {
	var p = new(SelectStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_selectStmt
	return p
}

func InitEmptySelectStmtContext(p *SelectStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_selectStmt
}

func (*SelectStmtContext) IsSelectStmtContext() {}

func NewSelectStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStmtContext {
	var p = new(SelectStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_selectStmt

	return p
}

func (s *SelectStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStmtContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ChainParserSELECT, 0)
}

func (s *SelectStmtContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserL_CURLY, 0)
}

func (s *SelectStmtContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserR_CURLY, 0)
}

func (s *SelectStmtContext) AllCommClause() []ICommClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommClauseContext); ok {
			len++
		}
	}

	tst := make([]ICommClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommClauseContext); ok {
			tst[i] = t.(ICommClauseContext)
			i++
		}
	}

	return tst
}

func (s *SelectStmtContext) CommClause(i int) ICommClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommClauseContext)
}

func (s *SelectStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterSelectStmt(s)
	}
}

func (s *SelectStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitSelectStmt(s)
	}
}

func (s *SelectStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitSelectStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) SelectStmt() (localctx ISelectStmtContext) {
	localctx = NewSelectStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ChainParserRULE_selectStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Match(ChainParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(793)
		p.Match(ChainParserL_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserCASE || _la == ChainParserDEFAULT {
		{
			p.SetState(794)
			p.CommClause()
		}

		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(800)
		p.Match(ChainParserR_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommClauseContext is an interface to support dynamic dispatch.
type ICommClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommCase() ICommCaseContext
	COLON() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsCommClauseContext differentiates from other interfaces.
	IsCommClauseContext()
}

type CommClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommClauseContext() *CommClauseContext {
	var p = new(CommClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_commClause
	return p
}

func InitEmptyCommClauseContext(p *CommClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_commClause
}

func (*CommClauseContext) IsCommClauseContext() {}

func NewCommClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommClauseContext {
	var p = new(CommClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_commClause

	return p
}

func (s *CommClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CommClauseContext) CommCase() ICommCaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommCaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommCaseContext)
}

func (s *CommClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *CommClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CommClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterCommClause(s)
	}
}

func (s *CommClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitCommClause(s)
	}
}

func (s *CommClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitCommClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) CommClause() (localctx ICommClauseContext) {
	localctx = NewCommClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ChainParserRULE_commClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.CommCase()
	}
	{
		p.SetState(803)
		p.Match(ChainParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(804)
		p.StatementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommCaseContext is an interface to support dynamic dispatch.
type ICommCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	SendStmt() ISendStmtContext
	RecvStmt() IRecvStmtContext
	DEFAULT() antlr.TerminalNode

	// IsCommCaseContext differentiates from other interfaces.
	IsCommCaseContext()
}

type CommCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommCaseContext() *CommCaseContext {
	var p = new(CommCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_commCase
	return p
}

func InitEmptyCommCaseContext(p *CommCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_commCase
}

func (*CommCaseContext) IsCommCaseContext() {}

func NewCommCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommCaseContext {
	var p = new(CommCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_commCase

	return p
}

func (s *CommCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CommCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(ChainParserCASE, 0)
}

func (s *CommCaseContext) SendStmt() ISendStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendStmtContext)
}

func (s *CommCaseContext) RecvStmt() IRecvStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecvStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecvStmtContext)
}

func (s *CommCaseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ChainParserDEFAULT, 0)
}

func (s *CommCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterCommCase(s)
	}
}

func (s *CommCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitCommCase(s)
	}
}

func (s *CommCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitCommCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) CommCase() (localctx ICommCaseContext) {
	localctx = NewCommCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ChainParserRULE_commCase)
	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(806)
			p.Match(ChainParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(807)
				p.SendStmt()
			}

		case 2:
			{
				p.SetState(808)
				p.RecvStmt()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case ChainParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(811)
			p.Match(ChainParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecvStmtContext is an interface to support dynamic dispatch.
type IRecvStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRecvExpr returns the recvExpr rule contexts.
	GetRecvExpr() IExpressionContext

	// SetRecvExpr sets the recvExpr rule contexts.
	SetRecvExpr(IExpressionContext)

	// Getter signatures
	Expression() IExpressionContext
	ExpressionList() IExpressionListContext
	ASSIGN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DECLARE_ASSIGN() antlr.TerminalNode

	// IsRecvStmtContext differentiates from other interfaces.
	IsRecvStmtContext()
}

type RecvStmtContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	recvExpr IExpressionContext
}

func NewEmptyRecvStmtContext() *RecvStmtContext {
	var p = new(RecvStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_recvStmt
	return p
}

func InitEmptyRecvStmtContext(p *RecvStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_recvStmt
}

func (*RecvStmtContext) IsRecvStmtContext() {}

func NewRecvStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecvStmtContext {
	var p = new(RecvStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_recvStmt

	return p
}

func (s *RecvStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RecvStmtContext) GetRecvExpr() IExpressionContext { return s.recvExpr }

func (s *RecvStmtContext) SetRecvExpr(v IExpressionContext) { s.recvExpr = v }

func (s *RecvStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RecvStmtContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RecvStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserASSIGN, 0)
}

func (s *RecvStmtContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RecvStmtContext) DECLARE_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserDECLARE_ASSIGN, 0)
}

func (s *RecvStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecvStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecvStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterRecvStmt(s)
	}
}

func (s *RecvStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitRecvStmt(s)
	}
}

func (s *RecvStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitRecvStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) RecvStmt() (localctx IRecvStmtContext) {
	localctx = NewRecvStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ChainParserRULE_recvStmt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(820)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(814)
			p.ExpressionList()
		}
		{
			p.SetState(815)
			p.Match(ChainParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(817)
			p.IdentifierList()
		}
		{
			p.SetState(818)
			p.Match(ChainParserDECLARE_ASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(822)

		var _x = p.expression(0)

		localctx.(*RecvStmtContext).recvExpr = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStmtContext is an interface to support dynamic dispatch.
type IForStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Block() IBlockContext
	Condition() IConditionContext
	ForClause() IForClauseContext
	RangeClause() IRangeClauseContext

	// IsForStmtContext differentiates from other interfaces.
	IsForStmtContext()
}

type ForStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStmtContext() *ForStmtContext {
	var p = new(ForStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_forStmt
	return p
}

func InitEmptyForStmtContext(p *ForStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_forStmt
}

func (*ForStmtContext) IsForStmtContext() {}

func NewForStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStmtContext {
	var p = new(ForStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_forStmt

	return p
}

func (s *ForStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(ChainParserFOR, 0)
}

func (s *ForStmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForStmtContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *ForStmtContext) ForClause() IForClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForClauseContext)
}

func (s *ForStmtContext) RangeClause() IRangeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeClauseContext)
}

func (s *ForStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterForStmt(s)
	}
}

func (s *ForStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitForStmt(s)
	}
}

func (s *ForStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitForStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ForStmt() (localctx IForStmtContext) {
	localctx = NewForStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ChainParserRULE_forStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.Match(ChainParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(828)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(825)
			p.Condition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(826)
			p.ForClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(827)
			p.RangeClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(830)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_condition
	return p
}

func InitEmptyConditionContext(p *ConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_condition
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (s *ConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ChainParserRULE_condition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForClauseContext is an interface to support dynamic dispatch.
type IForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInitStmt returns the initStmt rule contexts.
	GetInitStmt() ISimpleStmtContext

	// GetPostStmt returns the postStmt rule contexts.
	GetPostStmt() ISimpleStmtContext

	// SetInitStmt sets the initStmt rule contexts.
	SetInitStmt(ISimpleStmtContext)

	// SetPostStmt sets the postStmt rule contexts.
	SetPostStmt(ISimpleStmtContext)

	// Getter signatures
	AllEos() []IEosContext
	Eos(i int) IEosContext
	Expression() IExpressionContext
	AllSimpleStmt() []ISimpleStmtContext
	SimpleStmt(i int) ISimpleStmtContext

	// IsForClauseContext differentiates from other interfaces.
	IsForClauseContext()
}

type ForClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	initStmt ISimpleStmtContext
	postStmt ISimpleStmtContext
}

func NewEmptyForClauseContext() *ForClauseContext {
	var p = new(ForClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_forClause
	return p
}

func InitEmptyForClauseContext(p *ForClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_forClause
}

func (*ForClauseContext) IsForClauseContext() {}

func NewForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForClauseContext {
	var p = new(ForClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_forClause

	return p
}

func (s *ForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ForClauseContext) GetInitStmt() ISimpleStmtContext { return s.initStmt }

func (s *ForClauseContext) GetPostStmt() ISimpleStmtContext { return s.postStmt }

func (s *ForClauseContext) SetInitStmt(v ISimpleStmtContext) { s.initStmt = v }

func (s *ForClauseContext) SetPostStmt(v ISimpleStmtContext) { s.postStmt = v }

func (s *ForClauseContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *ForClauseContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ForClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForClauseContext) AllSimpleStmt() []ISimpleStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			len++
		}
	}

	tst := make([]ISimpleStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleStmtContext); ok {
			tst[i] = t.(ISimpleStmtContext)
			i++
		}
	}

	return tst
}

func (s *ForClauseContext) SimpleStmt(i int) ISimpleStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStmtContext)
}

func (s *ForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterForClause(s)
	}
}

func (s *ForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitForClause(s)
	}
}

func (s *ForClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitForClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ForClause() (localctx IForClauseContext) {
	localctx = NewForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ChainParserRULE_forClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(835)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(834)

			var _x = p.SimpleStmt()

			localctx.(*ForClauseContext).initStmt = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(837)
		p.Eos()
	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(838)
			p.expression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(841)
		p.Eos()
	}
	p.SetState(843)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(842)

			var _x = p.SimpleStmt()

			localctx.(*ForClauseContext).postStmt = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeClauseContext is an interface to support dynamic dispatch.
type IRangeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RANGE() antlr.TerminalNode
	Expression() IExpressionContext
	ExpressionList() IExpressionListContext
	ASSIGN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DECLARE_ASSIGN() antlr.TerminalNode

	// IsRangeClauseContext differentiates from other interfaces.
	IsRangeClauseContext()
}

type RangeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeClauseContext() *RangeClauseContext {
	var p = new(RangeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_rangeClause
	return p
}

func InitEmptyRangeClauseContext(p *RangeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_rangeClause
}

func (*RangeClauseContext) IsRangeClauseContext() {}

func NewRangeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeClauseContext {
	var p = new(RangeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_rangeClause

	return p
}

func (s *RangeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeClauseContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ChainParserRANGE, 0)
}

func (s *RangeClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeClauseContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RangeClauseContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserASSIGN, 0)
}

func (s *RangeClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RangeClauseContext) DECLARE_ASSIGN() antlr.TerminalNode {
	return s.GetToken(ChainParserDECLARE_ASSIGN, 0)
}

func (s *RangeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterRangeClause(s)
	}
}

func (s *RangeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitRangeClause(s)
	}
}

func (s *RangeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitRangeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) RangeClause() (localctx IRangeClauseContext) {
	localctx = NewRangeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ChainParserRULE_rangeClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(851)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(845)
			p.ExpressionList()
		}
		{
			p.SetState(846)
			p.Match(ChainParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(848)
			p.IdentifierList()
		}
		{
			p.SetState(849)
			p.Match(ChainParserDECLARE_ASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(853)
		p.Match(ChainParserRANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(854)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGoStmtContext is an interface to support dynamic dispatch.
type IGoStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GO() antlr.TerminalNode
	Expression() IExpressionContext

	// IsGoStmtContext differentiates from other interfaces.
	IsGoStmtContext()
}

type GoStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoStmtContext() *GoStmtContext {
	var p = new(GoStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_goStmt
	return p
}

func InitEmptyGoStmtContext(p *GoStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_goStmt
}

func (*GoStmtContext) IsGoStmtContext() {}

func NewGoStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoStmtContext {
	var p = new(GoStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_goStmt

	return p
}

func (s *GoStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GoStmtContext) GO() antlr.TerminalNode {
	return s.GetToken(ChainParserGO, 0)
}

func (s *GoStmtContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GoStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterGoStmt(s)
	}
}

func (s *GoStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitGoStmt(s)
	}
}

func (s *GoStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitGoStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) GoStmt() (localctx IGoStmtContext) {
	localctx = NewGoStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ChainParserRULE_goStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.Match(ChainParserGO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(857)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	TypeArgs() ITypeArgsContext
	TypeLit() ITypeLitContext
	L_PAREN() antlr.TerminalNode
	Type_() IType_Context
	R_PAREN() antlr.TerminalNode

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *Type_Context) TypeArgs() ITypeArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgsContext)
}

func (s *Type_Context) TypeLit() ITypeLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeLitContext)
}

func (s *Type_Context) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *Type_Context) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *Type_Context) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitType_(s)
	}
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ChainParserRULE_type_)
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(859)
			p.TypeName()
		}
		p.SetState(861)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(860)
				p.TypeArgs()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(863)
			p.TypeLit()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(864)
			p.Match(ChainParserL_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(865)
			p.Type_()
		}
		{
			p.SetState(866)
			p.Match(ChainParserR_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgsContext is an interface to support dynamic dispatch.
type ITypeArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	TypeList() ITypeListContext
	R_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsTypeArgsContext differentiates from other interfaces.
	IsTypeArgsContext()
}

type TypeArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgsContext() *TypeArgsContext {
	var p = new(TypeArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeArgs
	return p
}

func InitEmptyTypeArgsContext(p *TypeArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeArgs
}

func (*TypeArgsContext) IsTypeArgsContext() {}

func NewTypeArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgsContext {
	var p = new(TypeArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeArgs

	return p
}

func (s *TypeArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgsContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserL_BRACKET, 0)
}

func (s *TypeArgsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeArgsContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserR_BRACKET, 0)
}

func (s *TypeArgsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, 0)
}

func (s *TypeArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeArgs(s)
	}
}

func (s *TypeArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeArgs(s)
	}
}

func (s *TypeArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeArgs() (localctx ITypeArgsContext) {
	localctx = NewTypeArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ChainParserRULE_typeArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.Match(ChainParserL_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(871)
		p.TypeList()
	}
	p.SetState(873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ChainParserCOMMA {
		{
			p.SetState(872)
			p.Match(ChainParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(875)
		p.Match(ChainParserR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdent() IQualifiedIdentContext
	IDENTIFIER() antlr.TerminalNode

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) QualifiedIdent() IQualifiedIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentContext)
}

func (s *TypeNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (s *TypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ChainParserRULE_typeName)
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(877)
			p.QualifiedIdent()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(878)
			p.Match(ChainParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeLitContext is an interface to support dynamic dispatch.
type ITypeLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayType() IArrayTypeContext
	StructType() IStructTypeContext
	PointerType() IPointerTypeContext
	FunctionType() IFunctionTypeContext
	InterfaceType() IInterfaceTypeContext
	SliceType() ISliceTypeContext
	MapType() IMapTypeContext
	ChannelType() IChannelTypeContext

	// IsTypeLitContext differentiates from other interfaces.
	IsTypeLitContext()
}

type TypeLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeLitContext() *TypeLitContext {
	var p = new(TypeLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeLit
	return p
}

func InitEmptyTypeLitContext(p *TypeLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeLit
}

func (*TypeLitContext) IsTypeLitContext() {}

func NewTypeLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeLitContext {
	var p = new(TypeLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeLit

	return p
}

func (s *TypeLitContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeLitContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeLitContext) StructType() IStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *TypeLitContext) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *TypeLitContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeLitContext) InterfaceType() IInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *TypeLitContext) SliceType() ISliceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISliceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISliceTypeContext)
}

func (s *TypeLitContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *TypeLitContext) ChannelType() IChannelTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelTypeContext)
}

func (s *TypeLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeLit(s)
	}
}

func (s *TypeLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeLit(s)
	}
}

func (s *TypeLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeLit() (localctx ITypeLitContext) {
	localctx = NewTypeLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ChainParserRULE_typeLit)
	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(881)
			p.ArrayType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(882)
			p.StructType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(883)
			p.PointerType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(884)
			p.FunctionType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(885)
			p.InterfaceType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(886)
			p.SliceType()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(887)
			p.MapType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(888)
			p.ChannelType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	ArrayLength() IArrayLengthContext
	R_BRACKET() antlr.TerminalNode
	ElementType() IElementTypeContext

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserL_BRACKET, 0)
}

func (s *ArrayTypeContext) ArrayLength() IArrayLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLengthContext)
}

func (s *ArrayTypeContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserR_BRACKET, 0)
}

func (s *ArrayTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ChainParserRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(891)
		p.Match(ChainParserL_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(892)
		p.ArrayLength()
	}
	{
		p.SetState(893)
		p.Match(ChainParserR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(894)
		p.ElementType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLengthContext is an interface to support dynamic dispatch.
type IArrayLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsArrayLengthContext differentiates from other interfaces.
	IsArrayLengthContext()
}

type ArrayLengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLengthContext() *ArrayLengthContext {
	var p = new(ArrayLengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_arrayLength
	return p
}

func InitEmptyArrayLengthContext(p *ArrayLengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_arrayLength
}

func (*ArrayLengthContext) IsArrayLengthContext() {}

func NewArrayLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLengthContext {
	var p = new(ArrayLengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_arrayLength

	return p
}

func (s *ArrayLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLengthContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterArrayLength(s)
	}
}

func (s *ArrayLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitArrayLength(s)
	}
}

func (s *ArrayLengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitArrayLength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ArrayLength() (localctx IArrayLengthContext) {
	localctx = NewArrayLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ChainParserRULE_arrayLength)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementTypeContext is an interface to support dynamic dispatch.
type IElementTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context

	// IsElementTypeContext differentiates from other interfaces.
	IsElementTypeContext()
}

type ElementTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementTypeContext() *ElementTypeContext {
	var p = new(ElementTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_elementType
	return p
}

func InitEmptyElementTypeContext(p *ElementTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_elementType
}

func (*ElementTypeContext) IsElementTypeContext() {}

func NewElementTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementTypeContext {
	var p = new(ElementTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_elementType

	return p
}

func (s *ElementTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ElementTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterElementType(s)
	}
}

func (s *ElementTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitElementType(s)
	}
}

func (s *ElementTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitElementType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ElementType() (localctx IElementTypeContext) {
	localctx = NewElementTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ChainParserRULE_elementType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Type_() IType_Context

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) STAR() antlr.TerminalNode {
	return s.GetToken(ChainParserSTAR, 0)
}

func (s *PointerTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (s *PointerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitPointerType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ChainParserRULE_pointerType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(900)
		p.Match(ChainParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(901)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	AllEos() []IEosContext
	Eos(i int) IEosContext
	AllMethodSpec() []IMethodSpecContext
	MethodSpec(i int) IMethodSpecContext
	AllTypeElement() []ITypeElementContext
	TypeElement(i int) ITypeElementContext

	// IsInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceTypeContext()
}

type InterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeContext() *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_interfaceType
	return p
}

func InitEmptyInterfaceTypeContext(p *InterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_interfaceType
}

func (*InterfaceTypeContext) IsInterfaceTypeContext() {}

func NewInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_interfaceType

	return p
}

func (s *InterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ChainParserINTERFACE, 0)
}

func (s *InterfaceTypeContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserL_CURLY, 0)
}

func (s *InterfaceTypeContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserR_CURLY, 0)
}

func (s *InterfaceTypeContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceTypeContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *InterfaceTypeContext) AllMethodSpec() []IMethodSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodSpecContext); ok {
			len++
		}
	}

	tst := make([]IMethodSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodSpecContext); ok {
			tst[i] = t.(IMethodSpecContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceTypeContext) MethodSpec(i int) IMethodSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodSpecContext)
}

func (s *InterfaceTypeContext) AllTypeElement() []ITypeElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeElementContext); ok {
			len++
		}
	}

	tst := make([]ITypeElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeElementContext); ok {
			tst[i] = t.(ITypeElementContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceTypeContext) TypeElement(i int) ITypeElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeElementContext)
}

func (s *InterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) InterfaceType() (localctx IInterfaceTypeContext) {
	localctx = NewInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ChainParserRULE_interfaceType)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(903)
		p.Match(ChainParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(904)
		p.Match(ChainParserL_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(907)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(905)
					p.MethodSpec()
				}

			case 2:
				{
					p.SetState(906)
					p.TypeElement()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(909)
				p.Eos()
			}

		}
		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(916)
		p.Match(ChainParserR_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISliceTypeContext is an interface to support dynamic dispatch.
type ISliceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	R_BRACKET() antlr.TerminalNode
	ElementType() IElementTypeContext

	// IsSliceTypeContext differentiates from other interfaces.
	IsSliceTypeContext()
}

type SliceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceTypeContext() *SliceTypeContext {
	var p = new(SliceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_sliceType
	return p
}

func InitEmptySliceTypeContext(p *SliceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_sliceType
}

func (*SliceTypeContext) IsSliceTypeContext() {}

func NewSliceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceTypeContext {
	var p = new(SliceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_sliceType

	return p
}

func (s *SliceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceTypeContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserL_BRACKET, 0)
}

func (s *SliceTypeContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserR_BRACKET, 0)
}

func (s *SliceTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *SliceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterSliceType(s)
	}
}

func (s *SliceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitSliceType(s)
	}
}

func (s *SliceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitSliceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) SliceType() (localctx ISliceTypeContext) {
	localctx = NewSliceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ChainParserRULE_sliceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(918)
		p.Match(ChainParserL_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(919)
		p.Match(ChainParserR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(920)
		p.ElementType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAP() antlr.TerminalNode
	L_BRACKET() antlr.TerminalNode
	Type_() IType_Context
	R_BRACKET() antlr.TerminalNode
	ElementType() IElementTypeContext

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_mapType
	return p
}

func InitEmptyMapTypeContext(p *MapTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_mapType
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(ChainParserMAP, 0)
}

func (s *MapTypeContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserL_BRACKET, 0)
}

func (s *MapTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *MapTypeContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserR_BRACKET, 0)
}

func (s *MapTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterMapType(s)
	}
}

func (s *MapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitMapType(s)
	}
}

func (s *MapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitMapType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) MapType() (localctx IMapTypeContext) {
	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ChainParserRULE_mapType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(922)
		p.Match(ChainParserMAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(923)
		p.Match(ChainParserL_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(924)
		p.Type_()
	}
	{
		p.SetState(925)
		p.Match(ChainParserR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(926)
		p.ElementType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelTypeContext is an interface to support dynamic dispatch.
type IChannelTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementType() IElementTypeContext
	CHAN() antlr.TerminalNode
	RECEIVE() antlr.TerminalNode

	// IsChannelTypeContext differentiates from other interfaces.
	IsChannelTypeContext()
}

type ChannelTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelTypeContext() *ChannelTypeContext {
	var p = new(ChannelTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_channelType
	return p
}

func InitEmptyChannelTypeContext(p *ChannelTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_channelType
}

func (*ChannelTypeContext) IsChannelTypeContext() {}

func NewChannelTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelTypeContext {
	var p = new(ChannelTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_channelType

	return p
}

func (s *ChannelTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *ChannelTypeContext) CHAN() antlr.TerminalNode {
	return s.GetToken(ChainParserCHAN, 0)
}

func (s *ChannelTypeContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(ChainParserRECEIVE, 0)
}

func (s *ChannelTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterChannelType(s)
	}
}

func (s *ChannelTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitChannelType(s)
	}
}

func (s *ChannelTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitChannelType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ChannelType() (localctx IChannelTypeContext) {
	localctx = NewChannelTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ChainParserRULE_channelType)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.SetState(928)

		if !(p.isNotReceive()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.isNotReceive()", ""))
			goto errorExit
		}
		{
			p.SetState(929)
			p.Match(ChainParserCHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(930)
			p.Match(ChainParserCHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(931)
			p.Match(ChainParserRECEIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(932)
			p.Match(ChainParserRECEIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(933)
			p.Match(ChainParserCHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(936)
		p.ElementType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodSpecContext is an interface to support dynamic dispatch.
type IMethodSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Parameters() IParametersContext
	Result() IResultContext

	// IsMethodSpecContext differentiates from other interfaces.
	IsMethodSpecContext()
}

type MethodSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodSpecContext() *MethodSpecContext {
	var p = new(MethodSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_methodSpec
	return p
}

func InitEmptyMethodSpecContext(p *MethodSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_methodSpec
}

func (*MethodSpecContext) IsMethodSpecContext() {}

func NewMethodSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodSpecContext {
	var p = new(MethodSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_methodSpec

	return p
}

func (s *MethodSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *MethodSpecContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *MethodSpecContext) Result() IResultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *MethodSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterMethodSpec(s)
	}
}

func (s *MethodSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitMethodSpec(s)
	}
}

func (s *MethodSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitMethodSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) MethodSpec() (localctx IMethodSpecContext) {
	localctx = NewMethodSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ChainParserRULE_methodSpec)
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(938)
			p.Match(ChainParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(939)
			p.Parameters()
		}
		{
			p.SetState(940)
			p.Result()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(942)
			p.Match(ChainParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(943)
			p.Parameters()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	Signature() ISignatureContext

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ChainParserFUNC, 0)
}

func (s *FunctionTypeContext) Signature() ISignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ChainParserRULE_functionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(946)
		p.Match(ChainParserFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(947)
		p.Signature()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignatureContext is an interface to support dynamic dispatch.
type ISignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parameters() IParametersContext
	Result() IResultContext

	// IsSignatureContext differentiates from other interfaces.
	IsSignatureContext()
}

type SignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignatureContext() *SignatureContext {
	var p = new(SignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_signature
	return p
}

func InitEmptySignatureContext(p *SignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_signature
}

func (*SignatureContext) IsSignatureContext() {}

func NewSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignatureContext {
	var p = new(SignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_signature

	return p
}

func (s *SignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *SignatureContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *SignatureContext) Result() IResultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *SignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterSignature(s)
	}
}

func (s *SignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitSignature(s)
	}
}

func (s *SignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Signature() (localctx ISignatureContext) {
	localctx = NewSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ChainParserRULE_signature)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(949)
		p.Parameters()
	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(950)
			p.Result()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultContext is an interface to support dynamic dispatch.
type IResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parameters() IParametersContext
	Type_() IType_Context

	// IsResultContext differentiates from other interfaces.
	IsResultContext()
}

type ResultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultContext() *ResultContext {
	var p = new(ResultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_result
	return p
}

func InitEmptyResultContext(p *ResultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_result
}

func (*ResultContext) IsResultContext() {}

func NewResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultContext {
	var p = new(ResultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_result

	return p
}

func (s *ResultContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *ResultContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterResult(s)
	}
}

func (s *ResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitResult(s)
	}
}

func (s *ResultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitResult(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Result() (localctx IResultContext) {
	localctx = NewResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ChainParserRULE_result)
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(953)
			p.Parameters()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(954)
			p.Type_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	AllParameterDecl() []IParameterDeclContext
	ParameterDecl(i int) IParameterDeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *ParametersContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *ParametersContext) AllParameterDecl() []IParameterDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterDeclContext); ok {
			len++
		}
	}

	tst := make([]IParameterDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterDeclContext); ok {
			tst[i] = t.(IParameterDeclContext)
			i++
		}
	}

	return tst
}

func (s *ParametersContext) ParameterDecl(i int) IParameterDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclContext)
}

func (s *ParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ChainParserCOMMA)
}

func (s *ParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, i)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ChainParserRULE_parameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(957)
		p.Match(ChainParserL_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(958)
			p.ParameterDecl()
		}
		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(959)
					p.Match(ChainParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(960)
					p.ParameterDecl()
				}

			}
			p.SetState(965)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ChainParserCOMMA {
			{
				p.SetState(966)
				p.Match(ChainParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(971)
		p.Match(ChainParserR_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterDeclContext is an interface to support dynamic dispatch.
type IParameterDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	IdentifierList() IIdentifierListContext
	ELLIPSIS() antlr.TerminalNode

	// IsParameterDeclContext differentiates from other interfaces.
	IsParameterDeclContext()
}

type ParameterDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclContext() *ParameterDeclContext {
	var p = new(ParameterDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_parameterDecl
	return p
}

func InitEmptyParameterDeclContext(p *ParameterDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_parameterDecl
}

func (*ParameterDeclContext) IsParameterDeclContext() {}

func NewParameterDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclContext {
	var p = new(ParameterDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_parameterDecl

	return p
}

func (s *ParameterDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ParameterDeclContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ParameterDeclContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ChainParserELLIPSIS, 0)
}

func (s *ParameterDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterParameterDecl(s)
	}
}

func (s *ParameterDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitParameterDecl(s)
	}
}

func (s *ParameterDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitParameterDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ParameterDecl() (localctx IParameterDeclContext) {
	localctx = NewParameterDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ChainParserRULE_parameterDecl)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(974)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(973)
			p.IdentifierList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(977)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(976)
			p.Match(ChainParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(979)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnary_op returns the unary_op token.
	GetUnary_op() antlr.Token

	// GetMul_op returns the mul_op token.
	GetMul_op() antlr.Token

	// GetAdd_op returns the add_op token.
	GetAdd_op() antlr.Token

	// GetRel_op returns the rel_op token.
	GetRel_op() antlr.Token

	// SetUnary_op sets the unary_op token.
	SetUnary_op(antlr.Token)

	// SetMul_op sets the mul_op token.
	SetMul_op(antlr.Token)

	// SetAdd_op sets the add_op token.
	SetAdd_op(antlr.Token)

	// SetRel_op sets the rel_op token.
	SetRel_op(antlr.Token)

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	EXCLAMATION() antlr.TerminalNode
	CARET() antlr.TerminalNode
	STAR() antlr.TerminalNode
	AMPERSAND() antlr.TerminalNode
	RECEIVE() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	LSHIFT() antlr.TerminalNode
	RSHIFT() antlr.TerminalNode
	BIT_CLEAR() antlr.TerminalNode
	OR() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	NOT_EQUALS() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LESS_OR_EQUALS() antlr.TerminalNode
	GREATER() antlr.TerminalNode
	GREATER_OR_EQUALS() antlr.TerminalNode
	LOGICAL_AND() antlr.TerminalNode
	LOGICAL_OR() antlr.TerminalNode

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	unary_op antlr.Token
	mul_op   antlr.Token
	add_op   antlr.Token
	rel_op   antlr.Token
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) GetUnary_op() antlr.Token { return s.unary_op }

func (s *ExpressionContext) GetMul_op() antlr.Token { return s.mul_op }

func (s *ExpressionContext) GetAdd_op() antlr.Token { return s.add_op }

func (s *ExpressionContext) GetRel_op() antlr.Token { return s.rel_op }

func (s *ExpressionContext) SetUnary_op(v antlr.Token) { s.unary_op = v }

func (s *ExpressionContext) SetMul_op(v antlr.Token) { s.mul_op = v }

func (s *ExpressionContext) SetAdd_op(v antlr.Token) { s.add_op = v }

func (s *ExpressionContext) SetRel_op(v antlr.Token) { s.rel_op = v }

func (s *ExpressionContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ChainParserPLUS, 0)
}

func (s *ExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ChainParserMINUS, 0)
}

func (s *ExpressionContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ChainParserEXCLAMATION, 0)
}

func (s *ExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(ChainParserCARET, 0)
}

func (s *ExpressionContext) STAR() antlr.TerminalNode {
	return s.GetToken(ChainParserSTAR, 0)
}

func (s *ExpressionContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ChainParserAMPERSAND, 0)
}

func (s *ExpressionContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(ChainParserRECEIVE, 0)
}

func (s *ExpressionContext) DIV() antlr.TerminalNode {
	return s.GetToken(ChainParserDIV, 0)
}

func (s *ExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(ChainParserMOD, 0)
}

func (s *ExpressionContext) LSHIFT() antlr.TerminalNode {
	return s.GetToken(ChainParserLSHIFT, 0)
}

func (s *ExpressionContext) RSHIFT() antlr.TerminalNode {
	return s.GetToken(ChainParserRSHIFT, 0)
}

func (s *ExpressionContext) BIT_CLEAR() antlr.TerminalNode {
	return s.GetToken(ChainParserBIT_CLEAR, 0)
}

func (s *ExpressionContext) OR() antlr.TerminalNode {
	return s.GetToken(ChainParserOR, 0)
}

func (s *ExpressionContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ChainParserEQUALS, 0)
}

func (s *ExpressionContext) NOT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ChainParserNOT_EQUALS, 0)
}

func (s *ExpressionContext) LESS() antlr.TerminalNode {
	return s.GetToken(ChainParserLESS, 0)
}

func (s *ExpressionContext) LESS_OR_EQUALS() antlr.TerminalNode {
	return s.GetToken(ChainParserLESS_OR_EQUALS, 0)
}

func (s *ExpressionContext) GREATER() antlr.TerminalNode {
	return s.GetToken(ChainParserGREATER, 0)
}

func (s *ExpressionContext) GREATER_OR_EQUALS() antlr.TerminalNode {
	return s.GetToken(ChainParserGREATER_OR_EQUALS, 0)
}

func (s *ExpressionContext) LOGICAL_AND() antlr.TerminalNode {
	return s.GetToken(ChainParserLOGICAL_AND, 0)
}

func (s *ExpressionContext) LOGICAL_OR() antlr.TerminalNode {
	return s.GetToken(ChainParserLOGICAL_OR, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *ChainParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 198
	p.EnterRecursionRule(localctx, 198, ChainParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(982)
			p.PrimaryExpr()
		}

	case 2:
		{
			p.SetState(983)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExpressionContext).unary_op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&127) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExpressionContext).unary_op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(984)
			p.expression(6)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1002)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ChainParserRULE_expression)
				p.SetState(987)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(988)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).mul_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-61)) & ^0x3f) == 0 && ((int64(1)<<(_la-61))&3103) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).mul_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(989)
					p.expression(6)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ChainParserRULE_expression)
				p.SetState(990)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(991)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).add_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-60)) & ^0x3f) == 0 && ((int64(1)<<(_la-60))&1793) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).add_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(992)
					p.expression(5)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ChainParserRULE_expression)
				p.SetState(993)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(994)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).rel_op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1134907106097364992) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).rel_op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(995)
					p.expression(4)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ChainParserRULE_expression)
				p.SetState(996)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(997)
					p.Match(ChainParserLOGICAL_AND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(998)
					p.expression(3)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ChainParserRULE_expression)
				p.SetState(999)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1000)
					p.Match(ChainParserLOGICAL_OR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1001)
					p.expression(2)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1006)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Operand() IOperandContext
	Conversion() IConversionContext
	MethodExpr() IMethodExprContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllIndex() []IIndexContext
	Index(i int) IIndexContext
	AllSlice_() []ISlice_Context
	Slice_(i int) ISlice_Context
	AllTypeAssertion() []ITypeAssertionContext
	TypeAssertion(i int) ITypeAssertionContext
	AllArguments() []IArgumentsContext
	Arguments(i int) IArgumentsContext

	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) Operand() IOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperandContext)
}

func (s *PrimaryExprContext) Conversion() IConversionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConversionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConversionContext)
}

func (s *PrimaryExprContext) MethodExpr() IMethodExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodExprContext)
}

func (s *PrimaryExprContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ChainParserDOT)
}

func (s *PrimaryExprContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserDOT, i)
}

func (s *PrimaryExprContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ChainParserIDENTIFIER)
}

func (s *PrimaryExprContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, i)
}

func (s *PrimaryExprContext) AllIndex() []IIndexContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexContext); ok {
			len++
		}
	}

	tst := make([]IIndexContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexContext); ok {
			tst[i] = t.(IIndexContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryExprContext) Index(i int) IIndexContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexContext)
}

func (s *PrimaryExprContext) AllSlice_() []ISlice_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISlice_Context); ok {
			len++
		}
	}

	tst := make([]ISlice_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISlice_Context); ok {
			tst[i] = t.(ISlice_Context)
			i++
		}
	}

	return tst
}

func (s *PrimaryExprContext) Slice_(i int) ISlice_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlice_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlice_Context)
}

func (s *PrimaryExprContext) AllTypeAssertion() []ITypeAssertionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAssertionContext); ok {
			len++
		}
	}

	tst := make([]ITypeAssertionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAssertionContext); ok {
			tst[i] = t.(ITypeAssertionContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryExprContext) TypeAssertion(i int) ITypeAssertionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAssertionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAssertionContext)
}

func (s *PrimaryExprContext) AllArguments() []IArgumentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentsContext); ok {
			len++
		}
	}

	tst := make([]IArgumentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentsContext); ok {
			tst[i] = t.(IArgumentsContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryExprContext) Arguments(i int) IArgumentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitPrimaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ChainParserRULE_primaryExpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1007)

		if !(p.isOperand()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.isOperand()", ""))
			goto errorExit
		}
		{
			p.SetState(1008)
			p.Operand()
		}

	case 2:
		p.SetState(1009)

		if !(p.isConversion()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.isConversion()", ""))
			goto errorExit
		}
		{
			p.SetState(1010)
			p.Conversion()
		}

	case 3:
		p.SetState(1011)

		if !(p.isMethodExpr()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.isMethodExpr()", ""))
			goto errorExit
		}
		{
			p.SetState(1012)
			p.MethodExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1021)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1015)
					p.Match(ChainParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1016)
					p.Match(ChainParserIDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				{
					p.SetState(1017)
					p.Index()
				}

			case 3:
				{
					p.SetState(1018)
					p.Slice_()
				}

			case 4:
				{
					p.SetState(1019)
					p.TypeAssertion()
				}

			case 5:
				{
					p.SetState(1020)
					p.Arguments()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConversionContext is an interface to support dynamic dispatch.
type IConversionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	L_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	R_PAREN() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsConversionContext differentiates from other interfaces.
	IsConversionContext()
}

type ConversionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConversionContext() *ConversionContext {
	var p = new(ConversionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_conversion
	return p
}

func InitEmptyConversionContext(p *ConversionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_conversion
}

func (*ConversionContext) IsConversionContext() {}

func NewConversionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConversionContext {
	var p = new(ConversionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_conversion

	return p
}

func (s *ConversionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConversionContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ConversionContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *ConversionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConversionContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *ConversionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, 0)
}

func (s *ConversionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConversionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConversionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterConversion(s)
	}
}

func (s *ConversionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitConversion(s)
	}
}

func (s *ConversionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitConversion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Conversion() (localctx IConversionContext) {
	localctx = NewConversionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ChainParserRULE_conversion)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Type_()
	}
	{
		p.SetState(1027)
		p.Match(ChainParserL_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1028)
		p.expression(0)
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ChainParserCOMMA {
		{
			p.SetState(1029)
			p.Match(ChainParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1032)
		p.Match(ChainParserR_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperandContext is an interface to support dynamic dispatch.
type IOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	OperandName() IOperandNameContext
	TypeArgs() ITypeArgsContext
	L_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	R_PAREN() antlr.TerminalNode

	// IsOperandContext differentiates from other interfaces.
	IsOperandContext()
}

type OperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperandContext() *OperandContext {
	var p = new(OperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_operand
	return p
}

func InitEmptyOperandContext(p *OperandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_operand
}

func (*OperandContext) IsOperandContext() {}

func NewOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperandContext {
	var p = new(OperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_operand

	return p
}

func (s *OperandContext) GetParser() antlr.Parser { return s.parser }

func (s *OperandContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *OperandContext) OperandName() IOperandNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperandNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperandNameContext)
}

func (s *OperandContext) TypeArgs() ITypeArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgsContext)
}

func (s *OperandContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *OperandContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OperandContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *OperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterOperand(s)
	}
}

func (s *OperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitOperand(s)
	}
}

func (s *OperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Operand() (localctx IOperandContext) {
	localctx = NewOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ChainParserRULE_operand)
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1034)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1035)
			p.OperandName()
		}
		p.SetState(1037)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1036)
				p.TypeArgs()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1039)
			p.Match(ChainParserL_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1040)
			p.expression(0)
		}
		{
			p.SetState(1041)
			p.Match(ChainParserR_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BasicLit() IBasicLitContext
	CompositeLit() ICompositeLitContext
	FunctionLit() IFunctionLitContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) BasicLit() IBasicLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasicLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasicLitContext)
}

func (s *LiteralContext) CompositeLit() ICompositeLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeLitContext)
}

func (s *LiteralContext) FunctionLit() IFunctionLitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLitContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ChainParserRULE_literal)
	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserNIL_LIT, ChainParserDECIMAL_LIT, ChainParserBINARY_LIT, ChainParserOCTAL_LIT, ChainParserHEX_LIT, ChainParserFLOAT_LIT, ChainParserIMAGINARY_LIT, ChainParserRUNE_LIT, ChainParserRAW_STRING_LIT, ChainParserINTERPRETED_STRING_LIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1045)
			p.BasicLit()
		}

	case ChainParserMAP, ChainParserSTRUCT, ChainParserIDENTIFIER, ChainParserL_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1046)
			p.CompositeLit()
		}

	case ChainParserFUNC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1047)
			p.FunctionLit()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBasicLitContext is an interface to support dynamic dispatch.
type IBasicLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NIL_LIT() antlr.TerminalNode
	Integer() IIntegerContext
	String_() IString_Context
	FLOAT_LIT() antlr.TerminalNode

	// IsBasicLitContext differentiates from other interfaces.
	IsBasicLitContext()
}

type BasicLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasicLitContext() *BasicLitContext {
	var p = new(BasicLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_basicLit
	return p
}

func InitEmptyBasicLitContext(p *BasicLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_basicLit
}

func (*BasicLitContext) IsBasicLitContext() {}

func NewBasicLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasicLitContext {
	var p = new(BasicLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_basicLit

	return p
}

func (s *BasicLitContext) GetParser() antlr.Parser { return s.parser }

func (s *BasicLitContext) NIL_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserNIL_LIT, 0)
}

func (s *BasicLitContext) Integer() IIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *BasicLitContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *BasicLitContext) FLOAT_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserFLOAT_LIT, 0)
}

func (s *BasicLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasicLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterBasicLit(s)
	}
}

func (s *BasicLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitBasicLit(s)
	}
}

func (s *BasicLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitBasicLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) BasicLit() (localctx IBasicLitContext) {
	localctx = NewBasicLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ChainParserRULE_basicLit)
	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ChainParserNIL_LIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1050)
			p.Match(ChainParserNIL_LIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ChainParserDECIMAL_LIT, ChainParserBINARY_LIT, ChainParserOCTAL_LIT, ChainParserHEX_LIT, ChainParserIMAGINARY_LIT, ChainParserRUNE_LIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1051)
			p.Integer()
		}

	case ChainParserRAW_STRING_LIT, ChainParserINTERPRETED_STRING_LIT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1052)
			p.String_()
		}

	case ChainParserFLOAT_LIT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1053)
			p.Match(ChainParserFLOAT_LIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LIT() antlr.TerminalNode
	BINARY_LIT() antlr.TerminalNode
	OCTAL_LIT() antlr.TerminalNode
	HEX_LIT() antlr.TerminalNode
	IMAGINARY_LIT() antlr.TerminalNode
	RUNE_LIT() antlr.TerminalNode

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_integer
	return p
}

func InitEmptyIntegerContext(p *IntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_integer
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) DECIMAL_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserDECIMAL_LIT, 0)
}

func (s *IntegerContext) BINARY_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserBINARY_LIT, 0)
}

func (s *IntegerContext) OCTAL_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserOCTAL_LIT, 0)
}

func (s *IntegerContext) HEX_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserHEX_LIT, 0)
}

func (s *IntegerContext) IMAGINARY_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserIMAGINARY_LIT, 0)
}

func (s *IntegerContext) RUNE_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserRUNE_LIT, 0)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterInteger(s)
	}
}

func (s *IntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitInteger(s)
	}
}

func (s *IntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ChainParserRULE_integer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&399) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperandNameContext is an interface to support dynamic dispatch.
type IOperandNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	QualifiedIdent() IQualifiedIdentContext

	// IsOperandNameContext differentiates from other interfaces.
	IsOperandNameContext()
}

type OperandNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperandNameContext() *OperandNameContext {
	var p = new(OperandNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_operandName
	return p
}

func InitEmptyOperandNameContext(p *OperandNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_operandName
}

func (*OperandNameContext) IsOperandNameContext() {}

func NewOperandNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperandNameContext {
	var p = new(OperandNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_operandName

	return p
}

func (s *OperandNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OperandNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *OperandNameContext) QualifiedIdent() IQualifiedIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentContext)
}

func (s *OperandNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperandNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperandNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterOperandName(s)
	}
}

func (s *OperandNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitOperandName(s)
	}
}

func (s *OperandNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitOperandName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) OperandName() (localctx IOperandNameContext) {
	localctx = NewOperandNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ChainParserRULE_operandName)
	p.SetState(1060)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1058)
			p.Match(ChainParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1059)
			p.QualifiedIdent()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedIdentContext is an interface to support dynamic dispatch.
type IQualifiedIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsQualifiedIdentContext differentiates from other interfaces.
	IsQualifiedIdentContext()
}

type QualifiedIdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdentContext() *QualifiedIdentContext {
	var p = new(QualifiedIdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_qualifiedIdent
	return p
}

func InitEmptyQualifiedIdentContext(p *QualifiedIdentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_qualifiedIdent
}

func (*QualifiedIdentContext) IsQualifiedIdentContext() {}

func NewQualifiedIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdentContext {
	var p = new(QualifiedIdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_qualifiedIdent

	return p
}

func (s *QualifiedIdentContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdentContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ChainParserIDENTIFIER)
}

func (s *QualifiedIdentContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, i)
}

func (s *QualifiedIdentContext) DOT() antlr.TerminalNode {
	return s.GetToken(ChainParserDOT, 0)
}

func (s *QualifiedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterQualifiedIdent(s)
	}
}

func (s *QualifiedIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitQualifiedIdent(s)
	}
}

func (s *QualifiedIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitQualifiedIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) QualifiedIdent() (localctx IQualifiedIdentContext) {
	localctx = NewQualifiedIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ChainParserRULE_qualifiedIdent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1062)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1063)
		p.Match(ChainParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1064)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositeLitContext is an interface to support dynamic dispatch.
type ICompositeLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LiteralType() ILiteralTypeContext
	LiteralValue() ILiteralValueContext

	// IsCompositeLitContext differentiates from other interfaces.
	IsCompositeLitContext()
}

type CompositeLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositeLitContext() *CompositeLitContext {
	var p = new(CompositeLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_compositeLit
	return p
}

func InitEmptyCompositeLitContext(p *CompositeLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_compositeLit
}

func (*CompositeLitContext) IsCompositeLitContext() {}

func NewCompositeLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositeLitContext {
	var p = new(CompositeLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_compositeLit

	return p
}

func (s *CompositeLitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositeLitContext) LiteralType() ILiteralTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralTypeContext)
}

func (s *CompositeLitContext) LiteralValue() ILiteralValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralValueContext)
}

func (s *CompositeLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositeLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositeLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterCompositeLit(s)
	}
}

func (s *CompositeLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitCompositeLit(s)
	}
}

func (s *CompositeLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitCompositeLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) CompositeLit() (localctx ICompositeLitContext) {
	localctx = NewCompositeLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ChainParserRULE_compositeLit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1066)
		p.LiteralType()
	}
	{
		p.SetState(1067)
		p.LiteralValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralTypeContext is an interface to support dynamic dispatch.
type ILiteralTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StructType() IStructTypeContext
	ArrayType() IArrayTypeContext
	L_BRACKET() antlr.TerminalNode
	ELLIPSIS() antlr.TerminalNode
	R_BRACKET() antlr.TerminalNode
	ElementType() IElementTypeContext
	SliceType() ISliceTypeContext
	MapType() IMapTypeContext
	TypeName() ITypeNameContext
	TypeArgs() ITypeArgsContext

	// IsLiteralTypeContext differentiates from other interfaces.
	IsLiteralTypeContext()
}

type LiteralTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralTypeContext() *LiteralTypeContext {
	var p = new(LiteralTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_literalType
	return p
}

func InitEmptyLiteralTypeContext(p *LiteralTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_literalType
}

func (*LiteralTypeContext) IsLiteralTypeContext() {}

func NewLiteralTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralTypeContext {
	var p = new(LiteralTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_literalType

	return p
}

func (s *LiteralTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralTypeContext) StructType() IStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *LiteralTypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *LiteralTypeContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserL_BRACKET, 0)
}

func (s *LiteralTypeContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ChainParserELLIPSIS, 0)
}

func (s *LiteralTypeContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserR_BRACKET, 0)
}

func (s *LiteralTypeContext) ElementType() IElementTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeContext)
}

func (s *LiteralTypeContext) SliceType() ISliceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISliceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISliceTypeContext)
}

func (s *LiteralTypeContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *LiteralTypeContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *LiteralTypeContext) TypeArgs() ITypeArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgsContext)
}

func (s *LiteralTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterLiteralType(s)
	}
}

func (s *LiteralTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitLiteralType(s)
	}
}

func (s *LiteralTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitLiteralType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) LiteralType() (localctx ILiteralTypeContext) {
	localctx = NewLiteralTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ChainParserRULE_literalType)
	var _la int

	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1069)
			p.StructType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1070)
			p.ArrayType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1071)
			p.Match(ChainParserL_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1072)
			p.Match(ChainParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1073)
			p.Match(ChainParserR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1074)
			p.ElementType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1075)
			p.SliceType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1076)
			p.MapType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1077)
			p.TypeName()
		}
		p.SetState(1079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ChainParserL_BRACKET {
			{
				p.SetState(1078)
				p.TypeArgs()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralValueContext is an interface to support dynamic dispatch.
type ILiteralValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	ElementList() IElementListContext
	COMMA() antlr.TerminalNode

	// IsLiteralValueContext differentiates from other interfaces.
	IsLiteralValueContext()
}

type LiteralValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralValueContext() *LiteralValueContext {
	var p = new(LiteralValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_literalValue
	return p
}

func InitEmptyLiteralValueContext(p *LiteralValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_literalValue
}

func (*LiteralValueContext) IsLiteralValueContext() {}

func NewLiteralValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralValueContext {
	var p = new(LiteralValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_literalValue

	return p
}

func (s *LiteralValueContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralValueContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserL_CURLY, 0)
}

func (s *LiteralValueContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserR_CURLY, 0)
}

func (s *LiteralValueContext) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *LiteralValueContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, 0)
}

func (s *LiteralValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterLiteralValue(s)
	}
}

func (s *LiteralValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitLiteralValue(s)
	}
}

func (s *LiteralValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitLiteralValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) LiteralValue() (localctx ILiteralValueContext) {
	localctx = NewLiteralValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ChainParserRULE_literalValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1083)
		p.Match(ChainParserL_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1084)
			p.ElementList()
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ChainParserCOMMA {
			{
				p.SetState(1085)
				p.Match(ChainParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1090)
		p.Match(ChainParserR_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllKeyedElement() []IKeyedElementContext
	KeyedElement(i int) IKeyedElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllKeyedElement() []IKeyedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyedElementContext); ok {
			len++
		}
	}

	tst := make([]IKeyedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyedElementContext); ok {
			tst[i] = t.(IKeyedElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) KeyedElement(i int) IKeyedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyedElementContext)
}

func (s *ElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ChainParserCOMMA)
}

func (s *ElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ChainParserRULE_elementList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1092)
		p.KeyedElement()
	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1093)
				p.Match(ChainParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1094)
				p.KeyedElement()
			}

		}
		p.SetState(1099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyedElementContext is an interface to support dynamic dispatch.
type IKeyedElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Element() IElementContext
	Key() IKeyContext
	COLON() antlr.TerminalNode

	// IsKeyedElementContext differentiates from other interfaces.
	IsKeyedElementContext()
}

type KeyedElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedElementContext() *KeyedElementContext {
	var p = new(KeyedElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_keyedElement
	return p
}

func InitEmptyKeyedElementContext(p *KeyedElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_keyedElement
}

func (*KeyedElementContext) IsKeyedElementContext() {}

func NewKeyedElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedElementContext {
	var p = new(KeyedElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_keyedElement

	return p
}

func (s *KeyedElementContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedElementContext) Element() IElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *KeyedElementContext) Key() IKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyContext)
}

func (s *KeyedElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, 0)
}

func (s *KeyedElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterKeyedElement(s)
	}
}

func (s *KeyedElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitKeyedElement(s)
	}
}

func (s *KeyedElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitKeyedElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) KeyedElement() (localctx IKeyedElementContext) {
	localctx = NewKeyedElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ChainParserRULE_keyedElement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1103)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1100)
			p.Key()
		}
		{
			p.SetState(1101)
			p.Match(ChainParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1105)
		p.Element()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyContext is an interface to support dynamic dispatch.
type IKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LiteralValue() ILiteralValueContext

	// IsKeyContext differentiates from other interfaces.
	IsKeyContext()
}

type KeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyContext() *KeyContext {
	var p = new(KeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_key
	return p
}

func InitEmptyKeyContext(p *KeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_key
}

func (*KeyContext) IsKeyContext() {}

func NewKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyContext {
	var p = new(KeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_key

	return p
}

func (s *KeyContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyContext) LiteralValue() ILiteralValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralValueContext)
}

func (s *KeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterKey(s)
	}
}

func (s *KeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitKey(s)
	}
}

func (s *KeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Key() (localctx IKeyContext) {
	localctx = NewKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ChainParserRULE_key)
	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1107)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1108)
			p.LiteralValue()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LiteralValue() ILiteralValueContext

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_element
	return p
}

func InitEmptyElementContext(p *ElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_element
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementContext) LiteralValue() ILiteralValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralValueContext)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitElement(s)
	}
}

func (s *ElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Element() (localctx IElementContext) {
	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ChainParserRULE_element)
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1111)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1112)
			p.LiteralValue()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructTypeContext is an interface to support dynamic dispatch.
type IStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	L_CURLY() antlr.TerminalNode
	R_CURLY() antlr.TerminalNode
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllEos() []IEosContext
	Eos(i int) IEosContext

	// IsStructTypeContext differentiates from other interfaces.
	IsStructTypeContext()
}

type StructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructTypeContext() *StructTypeContext {
	var p = new(StructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_structType
	return p
}

func InitEmptyStructTypeContext(p *StructTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_structType
}

func (*StructTypeContext) IsStructTypeContext() {}

func NewStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructTypeContext {
	var p = new(StructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_structType

	return p
}

func (s *StructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(ChainParserSTRUCT, 0)
}

func (s *StructTypeContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserL_CURLY, 0)
}

func (s *StructTypeContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ChainParserR_CURLY, 0)
}

func (s *StructTypeContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *StructTypeContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *StructTypeContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StructTypeContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterStructType(s)
	}
}

func (s *StructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitStructType(s)
	}
}

func (s *StructTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitStructType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) StructType() (localctx IStructTypeContext) {
	localctx = NewStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ChainParserRULE_structType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1115)
		p.Match(ChainParserSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1116)
		p.Match(ChainParserL_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ChainParserIDENTIFIER || _la == ChainParserSTAR {
		{
			p.SetState(1117)
			p.FieldDecl()
		}
		{
			p.SetState(1118)
			p.Eos()
		}

		p.SetState(1124)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1125)
		p.Match(ChainParserR_CURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclContext is an interface to support dynamic dispatch.
type IFieldDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTag returns the tag rule contexts.
	GetTag() IString_Context

	// SetTag sets the tag rule contexts.
	SetTag(IString_Context)

	// Getter signatures
	IdentifierList() IIdentifierListContext
	Type_() IType_Context
	EmbeddedField() IEmbeddedFieldContext
	String_() IString_Context

	// IsFieldDeclContext differentiates from other interfaces.
	IsFieldDeclContext()
}

type FieldDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tag    IString_Context
}

func NewEmptyFieldDeclContext() *FieldDeclContext {
	var p = new(FieldDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_fieldDecl
	return p
}

func InitEmptyFieldDeclContext(p *FieldDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_fieldDecl
}

func (*FieldDeclContext) IsFieldDeclContext() {}

func NewFieldDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclContext {
	var p = new(FieldDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_fieldDecl

	return p
}

func (s *FieldDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclContext) GetTag() IString_Context { return s.tag }

func (s *FieldDeclContext) SetTag(v IString_Context) { s.tag = v }

func (s *FieldDeclContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *FieldDeclContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FieldDeclContext) EmbeddedField() IEmbeddedFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmbeddedFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmbeddedFieldContext)
}

func (s *FieldDeclContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *FieldDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterFieldDecl(s)
	}
}

func (s *FieldDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitFieldDecl(s)
	}
}

func (s *FieldDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitFieldDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) FieldDecl() (localctx IFieldDeclContext) {
	localctx = NewFieldDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ChainParserRULE_fieldDecl)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1127)
			p.IdentifierList()
		}
		{
			p.SetState(1128)
			p.Type_()
		}

	case 2:
		{
			p.SetState(1130)
			p.EmbeddedField()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1134)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1133)

			var _x = p.String_()

			localctx.(*FieldDeclContext).tag = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IString_Context is an interface to support dynamic dispatch.
type IString_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAW_STRING_LIT() antlr.TerminalNode
	INTERPRETED_STRING_LIT() antlr.TerminalNode

	// IsString_Context differentiates from other interfaces.
	IsString_Context()
}

type String_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_Context() *String_Context {
	var p = new(String_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_string_
	return p
}

func InitEmptyString_Context(p *String_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_string_
}

func (*String_Context) IsString_Context() {}

func NewString_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_Context {
	var p = new(String_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_string_

	return p
}

func (s *String_Context) GetParser() antlr.Parser { return s.parser }

func (s *String_Context) RAW_STRING_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserRAW_STRING_LIT, 0)
}

func (s *String_Context) INTERPRETED_STRING_LIT() antlr.TerminalNode {
	return s.GetToken(ChainParserINTERPRETED_STRING_LIT, 0)
}

func (s *String_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterString_(s)
	}
}

func (s *String_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitString_(s)
	}
}

func (s *String_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitString_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) String_() (localctx IString_Context) {
	localctx = NewString_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ChainParserRULE_string_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ChainParserRAW_STRING_LIT || _la == ChainParserINTERPRETED_STRING_LIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmbeddedFieldContext is an interface to support dynamic dispatch.
type IEmbeddedFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	STAR() antlr.TerminalNode
	TypeArgs() ITypeArgsContext

	// IsEmbeddedFieldContext differentiates from other interfaces.
	IsEmbeddedFieldContext()
}

type EmbeddedFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmbeddedFieldContext() *EmbeddedFieldContext {
	var p = new(EmbeddedFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_embeddedField
	return p
}

func InitEmptyEmbeddedFieldContext(p *EmbeddedFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_embeddedField
}

func (*EmbeddedFieldContext) IsEmbeddedFieldContext() {}

func NewEmbeddedFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmbeddedFieldContext {
	var p = new(EmbeddedFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_embeddedField

	return p
}

func (s *EmbeddedFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *EmbeddedFieldContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EmbeddedFieldContext) STAR() antlr.TerminalNode {
	return s.GetToken(ChainParserSTAR, 0)
}

func (s *EmbeddedFieldContext) TypeArgs() ITypeArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgsContext)
}

func (s *EmbeddedFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmbeddedFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmbeddedFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterEmbeddedField(s)
	}
}

func (s *EmbeddedFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitEmbeddedField(s)
	}
}

func (s *EmbeddedFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitEmbeddedField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) EmbeddedField() (localctx IEmbeddedFieldContext) {
	localctx = NewEmbeddedFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ChainParserRULE_embeddedField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ChainParserSTAR {
		{
			p.SetState(1138)
			p.Match(ChainParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1141)
		p.TypeName()
	}
	p.SetState(1143)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1142)
			p.TypeArgs()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionLitContext is an interface to support dynamic dispatch.
type IFunctionLitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	Signature() ISignatureContext
	Block() IBlockContext

	// IsFunctionLitContext differentiates from other interfaces.
	IsFunctionLitContext()
}

type FunctionLitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLitContext() *FunctionLitContext {
	var p = new(FunctionLitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_functionLit
	return p
}

func InitEmptyFunctionLitContext(p *FunctionLitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_functionLit
}

func (*FunctionLitContext) IsFunctionLitContext() {}

func NewFunctionLitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLitContext {
	var p = new(FunctionLitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_functionLit

	return p
}

func (s *FunctionLitContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLitContext) FUNC() antlr.TerminalNode {
	return s.GetToken(ChainParserFUNC, 0)
}

func (s *FunctionLitContext) Signature() ISignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *FunctionLitContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionLitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionLitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterFunctionLit(s)
	}
}

func (s *FunctionLitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitFunctionLit(s)
	}
}

func (s *FunctionLitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitFunctionLit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) FunctionLit() (localctx IFunctionLitContext) {
	localctx = NewFunctionLitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ChainParserRULE_functionLit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.Match(ChainParserFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1146)
		p.Signature()
	}
	{
		p.SetState(1147)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexContext is an interface to support dynamic dispatch.
type IIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	R_BRACKET() antlr.TerminalNode

	// IsIndexContext differentiates from other interfaces.
	IsIndexContext()
}

type IndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexContext() *IndexContext {
	var p = new(IndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_index
	return p
}

func InitEmptyIndexContext(p *IndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_index
}

func (*IndexContext) IsIndexContext() {}

func NewIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexContext {
	var p = new(IndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_index

	return p
}

func (s *IndexContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserL_BRACKET, 0)
}

func (s *IndexContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserR_BRACKET, 0)
}

func (s *IndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterIndex(s)
	}
}

func (s *IndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitIndex(s)
	}
}

func (s *IndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Index() (localctx IIndexContext) {
	localctx = NewIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ChainParserRULE_index)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		p.Match(ChainParserL_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1150)
		p.expression(0)
	}
	{
		p.SetState(1151)
		p.Match(ChainParserR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlice_Context is an interface to support dynamic dispatch.
type ISlice_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_BRACKET() antlr.TerminalNode
	R_BRACKET() antlr.TerminalNode
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsSlice_Context differentiates from other interfaces.
	IsSlice_Context()
}

type Slice_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlice_Context() *Slice_Context {
	var p = new(Slice_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_slice_
	return p
}

func InitEmptySlice_Context(p *Slice_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_slice_
}

func (*Slice_Context) IsSlice_Context() {}

func NewSlice_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Slice_Context {
	var p = new(Slice_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_slice_

	return p
}

func (s *Slice_Context) GetParser() antlr.Parser { return s.parser }

func (s *Slice_Context) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserL_BRACKET, 0)
}

func (s *Slice_Context) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ChainParserR_BRACKET, 0)
}

func (s *Slice_Context) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(ChainParserCOLON)
}

func (s *Slice_Context) COLON(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserCOLON, i)
}

func (s *Slice_Context) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Slice_Context) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Slice_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Slice_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Slice_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterSlice_(s)
	}
}

func (s *Slice_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitSlice_(s)
	}
}

func (s *Slice_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitSlice_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Slice_() (localctx ISlice_Context) {
	localctx = NewSlice_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ChainParserRULE_slice_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1153)
		p.Match(ChainParserL_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1154)
				p.expression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1157)
			p.Match(ChainParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1158)
				p.expression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1161)
				p.expression(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1164)
			p.Match(ChainParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1165)
			p.expression(0)
		}
		{
			p.SetState(1166)
			p.Match(ChainParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1167)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1171)
		p.Match(ChainParserR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAssertionContext is an interface to support dynamic dispatch.
type ITypeAssertionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	L_PAREN() antlr.TerminalNode
	Type_() IType_Context
	R_PAREN() antlr.TerminalNode

	// IsTypeAssertionContext differentiates from other interfaces.
	IsTypeAssertionContext()
}

type TypeAssertionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAssertionContext() *TypeAssertionContext {
	var p = new(TypeAssertionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeAssertion
	return p
}

func InitEmptyTypeAssertionContext(p *TypeAssertionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_typeAssertion
}

func (*TypeAssertionContext) IsTypeAssertionContext() {}

func NewTypeAssertionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAssertionContext {
	var p = new(TypeAssertionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_typeAssertion

	return p
}

func (s *TypeAssertionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAssertionContext) DOT() antlr.TerminalNode {
	return s.GetToken(ChainParserDOT, 0)
}

func (s *TypeAssertionContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *TypeAssertionContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeAssertionContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *TypeAssertionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAssertionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAssertionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterTypeAssertion(s)
	}
}

func (s *TypeAssertionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitTypeAssertion(s)
	}
}

func (s *TypeAssertionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitTypeAssertion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) TypeAssertion() (localctx ITypeAssertionContext) {
	localctx = NewTypeAssertionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, ChainParserRULE_typeAssertion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1173)
		p.Match(ChainParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1174)
		p.Match(ChainParserL_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1175)
		p.Type_()
	}
	{
		p.SetState(1176)
		p.Match(ChainParserR_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_PAREN() antlr.TerminalNode
	R_PAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	Type_() IType_Context
	ELLIPSIS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserL_PAREN, 0)
}

func (s *ArgumentsContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ChainParserR_PAREN, 0)
}

func (s *ArgumentsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentsContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ArgumentsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ChainParserELLIPSIS, 0)
}

func (s *ArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ChainParserCOMMA)
}

func (s *ArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ChainParserCOMMA, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, ChainParserRULE_arguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1178)
		p.Match(ChainParserL_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
		p.SetState(1185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1179)
				p.ExpressionList()
			}

		case 2:
			{
				p.SetState(1180)
				p.Type_()
			}
			p.SetState(1183)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1181)
					p.Match(ChainParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1182)
					p.ExpressionList()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ChainParserELLIPSIS {
			{
				p.SetState(1187)
				p.Match(ChainParserELLIPSIS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ChainParserCOMMA {
			{
				p.SetState(1190)
				p.Match(ChainParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1195)
		p.Match(ChainParserR_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodExprContext is an interface to support dynamic dispatch.
type IMethodExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	DOT() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsMethodExprContext differentiates from other interfaces.
	IsMethodExprContext()
}

type MethodExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodExprContext() *MethodExprContext {
	var p = new(MethodExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_methodExpr
	return p
}

func InitEmptyMethodExprContext(p *MethodExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_methodExpr
}

func (*MethodExprContext) IsMethodExprContext() {}

func NewMethodExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodExprContext {
	var p = new(MethodExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_methodExpr

	return p
}

func (s *MethodExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodExprContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *MethodExprContext) DOT() antlr.TerminalNode {
	return s.GetToken(ChainParserDOT, 0)
}

func (s *MethodExprContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ChainParserIDENTIFIER, 0)
}

func (s *MethodExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterMethodExpr(s)
	}
}

func (s *MethodExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitMethodExpr(s)
	}
}

func (s *MethodExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitMethodExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) MethodExpr() (localctx IMethodExprContext) {
	localctx = NewMethodExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, ChainParserRULE_methodExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1197)
		p.Type_()
	}
	{
		p.SetState(1198)
		p.Match(ChainParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1199)
		p.Match(ChainParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	EOS() antlr.TerminalNode

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_eos
	return p
}

func InitEmptyEosContext(p *EosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ChainParserRULE_eos
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ChainParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ChainParserSEMI, 0)
}

func (s *EosContext) EOS() antlr.TerminalNode {
	return s.GetToken(ChainParserEOS, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.EnterEos(s)
	}
}

func (s *EosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ChainParserListener); ok {
		listenerT.ExitEos(s)
	}
}

func (s *EosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ChainParserVisitor:
		return t.VisitEos(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ChainParser) Eos() (localctx IEosContext) {
	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, ChainParserRULE_eos)
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1201)
			p.Match(ChainParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1202)
			p.Match(ChainParserEOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1203)

		if !(p.closingBracket()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.closingBracket()", ""))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *ChainParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 92:
		var t *ChannelTypeContext = nil
		if localctx != nil {
			t = localctx.(*ChannelTypeContext)
		}
		return p.ChannelType_Sempred(t, predIndex)

	case 99:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 100:
		var t *PrimaryExprContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExprContext)
		}
		return p.PrimaryExpr_Sempred(t, predIndex)

	case 125:
		var t *EosContext = nil
		if localctx != nil {
			t = localctx.(*EosContext)
		}
		return p.Eos_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ChainParser) ChannelType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.isNotReceive()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ChainParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ChainParser) PrimaryExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.isOperand()

	case 7:
		return p.isConversion()

	case 8:
		return p.isMethodExpr()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ChainParser) Eos_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.closingBracket()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
